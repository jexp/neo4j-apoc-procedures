== Collection of useful Procedures for Neo4j 3.x

Just build it with `mvn package`.
Then copy `target/apoc-1.0.0-SNAPSHOT.jar` to your server's `plugins` directory.

If you want to run embedded or use shell on a disk store, configure your `plugins` directory in `neo4j.properties` with `dbms.plugin.directory=path/to/plugins`.

== Calling Procedures within Cypher

This repository uses a recent build (SNAPSHOT or RC1) of Neo4j, so that it can leverage procedures being called within Cypher statements.
You can download it yourself from http://alpha.neohq.net

[source,cypher]
----
CALL apoc.load.json('http://example.com/map.json') YIELD value as person
MERGE (p:Person {name:person.name})
ON CREATE SET p.age = person.age, p.children = size(person.children)
----

== Included Procedures

=== Manual Indexes

Procedures to add to and query manual indexes

* `apoc.index.addNode(node,['prop1',...])` add node to an index for each label it has
* `apoc.index.addNodeByLabel(node,'Label',['prop1',...])` add node to an index for the given label
* `apoc.index.addRelationship(rel,['prop1',...])` add relationship to an index for its type

* `apoc.index.nodes('Label','prop:value*') YIELD node` lucene query on node index with the given label name
* `apoc.index.relationships('TYPE','prop:value*') YIELD rel` lucene query on relationship index with the given type name
* `apoc.index.between(node1,'TYPE',node2,'prop:value*') YIELD rel` lucene query on relationship index with the given type name bound by either or both sides (each node parameter can be null)
* `apoc.index.out(node,'TYPE','prop:value*') YIELD node` lucene query on relationship index with the given type name for *outgoing* relationship of the given node, *returns end-nodes*
* `apoc.index.in(node,'TYPE','prop:value*') YIELD node` lucene query on relationship index with the given type name for *incoming* relationship of the given node, *returns start-nodes*

=== Meta Graph

Returns a virtual graph that represents the labels and relationship-types available in your database and how they are connected.
NOTE: This doesn't work with the current Neo4j-Browser due to a JS issue, but you can test it with curl or other browsers.

* `CALL apoc.meta.graph` - examines the full graph to create the meta-graph
* `CALL apoc.meta.graphSample(sampleSize)` - examines a sample graph to create the meta-graph, default sampleSize is 100
* `CALL apoc.meta.data`  - examines a subset of the graph to provide a tabular meta information
* `CALL apoc.meta.type(value)`  - type name of a value (`INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST`)
* `CALL apoc.meta.isType(value,type)` - returns a row if type name matches none if not

[source,cypher]
----
MATCH (n:Person)
CALL apoc.meta.isType(n.age,"INTEGER")
RETURN n LIMIT 5
----

=== Locking


* `call apoc.lock.nodes([nodes])` acquires a write lock on the given nodes
* `call apoc.lock.rels([relationships])` acquires a write lock on the given relationship
* `call apoc.lock.all([nodes],[relationships])` acquires a write lock on the given nodes and relationships

=== from/toJson

* `CALL apoc.convert.toJson([1,2,3])`
* `CALL apoc.convert.toJson({a:42,b:\"foo\",c:[1,2,3]})`
* `CALL apoc.convert.fromJsonList('[1,2,3]')`
* `CALL apoc.convert.fromJsonMap('{\"a\":42,\"b\":\"foo\",\"c\":[1,2,3]}')`

=== Loading Data from RDBMS

* `CALL apoc.load.jdbc('jdbc:derby:derbyDB','PERSON') YIELD row CREATE (:Person {name:row.name})` load from relational database, either a full table or a sql statement
* `CALL apoc.load.jdbc('jdbc:derby:derbyDB','SELECT * FROM PERSON WHERE AGE > 18')` load from relational database, either a full table or a sql statement
* `CALL apoc.load.driver('org.apache.derby.jdbc.EmbeddedDriver')` register JDBC driver of source database

=== Loading Data from Web-APIs (JSON, XML)

* `CALL apoc.load.json('http://example.com/map.json') YIELD value as person CREATE (p:Person) SET p = person` load from JSON URL (e.g. web-api) to import JSON as stream of values if the JSON was an array or a single value if it was a map
* `CALL apoc.load.xml('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name` load from XML URL (e.g. web-api) to import XML as single nested map with attributes and `_type`, `_text` and `_children`x fields.

=== Creating Data

* `CALL apoc.create.node(['Label'], {key:value,...})` create node with dynamic labels
* `CALL apoc.create.nodes(['Label'], [{key:value,...}])` create multiple nodes with dynamic labels
* `CALL apoc.create.relationship(person1,'KNOWS',{key:value,...}, person2)` create relationship with dynamic rel-type

=== Virtual Nodes/Rels

Virtual Nodes and Relationships don't exist in the graph, they are only returned to the UI/user for representing a graph projection.
They can be visualized or processed otherwise.
Please note that they have negative id's.

* `CALL apoc.create.vNode(['Label'], {key:value,...})` returns a virtual node
* `CALL apoc.create.vNodes(['Label'], [{key:value,...}])` returns virtual nodes
* `CALL apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,...}, nodeTo)` returns a virtual relationship
* `CALL apoc.create.vPattern({_labels:['LabelA'],key:value},'KNOWS',{key:value,...}, {_labels:['LabelB'],key:value})` returns a virtual pattern
* `CALL apoc.create.vPatternFull(['LabelA'],{key:value},'KNOWS',{key:value,...},['LabelB'],{key:value})` returns a virtual pattern

* TODO `CALL apoc.create.vGraph([nodes, {_labels:[],... prop:value,...}], [rels,{_from:keyValueFrom,_to:{_label:,_key:,_value:value}, _type:'KNOWS', prop:value,...}],['pk1','Label2:pk2'])

Example

[source,cypher]
----
MATCH (a)-[r]->(b)
WITH head(labels(a)) AS l, head(labels(b)) AS l2, type(r) AS rel_type, count(*) as count
CALL apoc.create.vNode(['Meta_Node'],{name:l}) yield node as a
CALL apoc.create.vNode(['Meta_Node'],{name:l2}) yield node as b
CALL apoc.create.vRelationship(a,'META_RELATIONSHIP',{name:rel_type, count:count},b) yield rel
RETURN *;
----

=== Job Management (WIP)

* `CALL apoc.jobs.list` list all jobs
* `CALL apoc.jobs.submit('name',statement)` submit a one-off background statement
* `CALL apoc.jobs.schedule('name',statement,repeat-time-in-seconds)` submit a repeatedly-called background statement
* there are also static methods `Jobs.submit`, and `Jobs.schedule` to be used from other procedures
* jobs list is checked / cleared every 10s for finished jobs

=== Graph Refactoring

* √ `call apoc.refactor.cloneNodes([node1,node2,...])` clone nodes with their labels and properties
* √ `call apoc.refactor.cloneNodesWithRelationships([node1,node2,...])` clone nodes with their labels, properties and relationships
* √ `call apoc.refactor.mergeNodes([node1,node2])` merge nodes onto first in list
* √ `call apoc.refactor.to(rel, endNode)` redirect relationship to use new end-node
* √ `call apoc.refactor.from(rel, startNode)` redirect relationship to use new start-node
* √ `call apoc.refactor.setType(rel, 'NEW-TYPE')` change relationship-type
* merge nodes by label + property
* merge relationships
* extract node from relationship
* collapse node to relationship


=== Helpers


* `apoc.map.fromPairs([[key,value],[key2,value2],...])`
* `apoc.map.fromLists([keys],[values])`
* `apoc.map.fromValues([key,value,key1,value1])`
* `apoc.map.setKey(map,key,value)`

* `apoc.coll.sum([0.5,1,2.3])`
* `apoc.coll.min([0.5,1,2.3])`
* `apoc.coll.max([0.5,1,2.3])`
* `apoc.coll.sumLongs([1,3,3])`
* `apoc.coll.partition(list,batchSize)`
* `apoc.coll.zip([list1],[list2])`
* `apoc.coll.pairs([list])` returns `[first,second],[second,third], ...
* `apoc.coll.sort(coll)` sort on Collections
* `apoc.coll.sortNodes([nodes], 'name')` sort nodes by property
* `apoc.coll.contains(coll, value)` optimized contains operation (using a HashSet) (returns single row or not)
* `apoc.coll.containsSorted(coll, value)` optimized contains on a sorted list operation (Collections.binarySearch) (returns single row or not)


=== Date/time Support

==== Conversion between formatted dates and timestamps

* `apoc.date.toSeconds('2015-03-25 03:15:59')` get Unix time equivalent of given date (in seconds)
* `apoc.date.toSecondsFormatted('2015/03/25 03-15-59', 'yyyy/MM/dd HH/mm/ss')` same as previous, but accepts custom datetime format
* `apoc.date.fromSeconds(12345)` get string representation of date corresponding to given Unix time (in seconds)
* `apoc.date.fromSecondsFormatted(12345, 'yyyy/MM/dd HH/mm/ss')` the same as previous, but accepts custom datetime format

==== Reading separate datetime fields:

Splits date (optionally, using given custom format) into fields returning a map from field name to its value.
Following fields are supported:

[options="header"]
|===============================================================================================================
| Result field	| Represents
| 'Years'		| year
| 'Months' 		| month of year
| 'Days' 		| day of month
| 'Hours' 		| hour of day
| 'Minutes' 	| minute of hour
| 'Seconds'		| second of minute
| 'ZoneId'		| https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html#timezone[time zone]
|===============================================================================================================

==== Examples

....
  apoc.date.listFields('2015-03-25 03:15:59') =>
    {
      'Months': 1,
      'Days': 2,
      'Hours': 3,
      'Minutes': 4,
      'Seconds': 5,
      'Years': 2015
    }
....

....
apoc.date.listFieldsFormatted('2015-01-02 03:04:05 EET', 'yyyy-MM-dd HH:mm:ss zzz') =>
  {
    'ZoneId': 'Europe/Bucharest',
    'Months': 1,
    'Days': 2,
    'Hours': 3,
    'Minutes': 4,
    'Seconds': 5,
    'Years': 2015
  }
....

....
apoc.date.listFieldsFormatted('2015/01/02_EET', 'yyyy/MM/dd_z') =>
  {
    'Years': 2015,
    'ZoneId': 'Europe/Bucharest',
    'Months': 1,
    'Days': 2
  }
....


==== Notes on formats:

* the default format is `yyyy-MM-dd HH:mm:ss`
* if the format pattern doesn't specify timezone, formatter considers dates to belong to the UTC timezone
* if the timezone pattern is specified, the timezone is extracted from the date string, otherwise an error will be reported
* the `to/fromSeconds` timestamp values are in POSIX (Unix time) system, i.e. timestamps represent the number of seconds elapsed since https://en.wikipedia.org/wiki/Unix_time[00:00:00 UTC, Thursday, 1 January 1970]
* the full list of supported formats is described in https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html[SimpleDateFormat JavaDoc]

== Plans

* warmup procedures that load nodes / rels by skipping one page at a time (8kb/15bytes) (8kb/35bytes)
* √ virtual nodes and rels
* √ meta graph
* √ manual indexes
* √ map functions, e.g. create map from pairs, from two lists, alternating key-value entries in a list, set map keys dynamically
* √ collection functions, like `pairs(collection, step)` or `zip(coll1,coll2, colln)`
* √ access to property value type and additional conversions
* √ lockNodes(), lockRels(), or lock(nodes, rels) (either of which can be empty or null)
* parallel(fragment, params-list, result list)
* in browser guide as apoc-help-page
* √ optimized collection functions
* Time Conversion Functions (ISO<->ts, padded long representation)
* custom expanders, e.g. with rel-type suffixes
* meta graph with sampling
* ordered, limited retrieval from index (both manual and schema index)
* help procs
* json to graph (mapping)
* virtual graph from collection of nodes and rels, handle node-uniqueness with pk
* RDF / Ontology loader
* Encryption / decryption of single properties or a subset or all properties (provide decryption key as param or config)
* Graph Algorithms

== Later Plans

* Graph Refactorings (WIP)
* Job Queue (WIP) See https://github.com/jakewins/neo4j-procedure-template/blob/batch/src/main/java/example/BatchedWrites.java[BatchedWriter from Jake/Max]
* eval javascript
* Procedures in other languages (e.g. JS)

== License

Apache License 2.0
