[[path-expander-paths-config]]
== Expand paths with config

[abstract]
--
This section describes a procedure that can be used to expand the paths of variable length path traversals, while providing configuration options.
--

The expand paths with config procedure enables powerful variable length path traversals with fine grained control over the traversals.
See <<path-expander-paths>> for a more basic version of the algorithm if fine grained control over traversals isn't required.

This section includes:

* <<path-expander-paths-config-overview>>
* <<path-expander-paths-config-config>>
* <<path-expander-paths-config-config-sequences>>
* <<path-expander-paths-config-examples>>
    ** <<path-expander-paths-config-examples-sequence-node-labels>>


[[path-expander-paths-config-overview]]
=== Procedure Overview

The procedure is described below:

[separator=Â¦,opts=header,cols="1,1m,1m,5"]
|===
include::../../../build/generated-documentation/apoc.path.expandConfig.csv[]
|===

[[path-expander-paths-config-config]]
=== Configuration parameters
The procedures support the following config parameters:

.Config parameters
[opts=header]
|===
| name | type | default | description
| minLevel | Long | -1 | the minimum number of hops in the traversal
| maxLevel | Long | -1 | the maximum number of hops in the traversal
| relationshipFilter | String | null | the relationship types and directions to traverse. See <<path-expander-paths-config-config-relationship-filters>>.
| labelFilter | String | null | the node labels to traverse. See <<path-expander-paths-config-config-label-filters>>.
| sequence | String | null | comma-separated alternating label and relationship filters, for each step in a repeating sequence.
If present, `labelFilter`, and `relationshipFilter` are ignored, as this takes priority.
See <<path-expander-paths-config-config-sequences>>.
| beginSequenceAtStart | Boolean | true | starts matching sequences of node labels and/or relationship types (defined in `relationshipFilter`, `labelFilter`, or `sequences`) one node away from the start node.
| uniqueness | String | RELATIONSHIP_PATH | the strategy to use when expanding relationships in a traversal. See <<path-expander-paths-config-config-uniqueness>>.
| bfs | Boolean | true | use Breadth First Search when traversing. Uses Depth First Search if set to `false`
| filterStartNode | Boolean | false | whether the `labelFilter` and `sequence` apply to the start node of the expansion.
| limit | Long | -1 | limit the number of paths returned. When using `bfs:true`, this has the effect of returning paths to the `n` nearest nodes with labels in the termination or end node filter, where `n` is the limit given.
| optional | Boolean | false | is path expansion optional?
If set to `true`, a `null` value is yielded whenever the expansion would normally eliminate rows due to no results.
| endNodes | List<Node> | null | only these nodes can end returned paths, and expansion will continue past these nodes, if possible.
| terminatorNodes | List<Node> | null | Only these nodes can end returned paths, and expansion won't continue past these nodes.
| whiteListNodes | List<Node> | null | Only these nodes are allowed in the expansion (though endNodes and terminatorNodes will also be allowed, if present).
| blackListNodes | List<Node> | null | None of the paths returned will include these nodes.
|===

[[path-expander-paths-config-config-relationship-filters]]
==== Relationship Filters

The syntax for relationship filters is described below:

include::relationship-filter.adoc[]

[[path-expander-paths-config-config-label-filters]]
==== Label Filters

The syntax for label filters is described below:

include::label-filter.adoc[]

*Label filter operator precedence and behavior*

include::label-filter-precedence.adoc[]

[[path-expander-paths-config-config-uniqueness]]
==== Uniqueness

include::uniqueness-expand.adoc[]

[[path-expander-paths-config-config-sequences]]
=== Specifying Sequences of node labels and relationship types

include::sequences.adoc[]
include::sequence-tips.adoc[]

[[path-expander-paths-config-examples]]
=== Examples

The examples in this section are based on the following sample graph:

include::expand-sample-graph.adoc[]

//[[path-expander-paths-config-examples-sequence-rel-types]]
//==== Sequences of relationship types
//
//Sequences of relationship types can be specified by comma separating the values passed to `relationshipFilter`.
//This is usually used in combination with `beginSequenceAtStart: false`, which means that sequences will start one hop away from the starting node.
//
//[source,cypher]
//----
//MATCH (p:Person {name: "Joe"})
//CALL apoc.path.expandConfig(p, {
//	relationshipFilter: "FOLLOWS>,KNOWS",
//	beginSequenceAtStart: false,
//	minLevel: 1,
//	maxLevel: 4
//})
//YIELD path
//RETURN path, length(path) AS hops
//ORDER BY hops;
//----

[[path-expander-paths-config-examples-sequence-node-labels]]
==== Sequences of node labels

Sequences of node labels can be specified by comma separating values passed to `labelFilter`.
This is usually used in combination with `beginSequenceAtStart: false`, which means that sequences will start one hop away from the starting node.

For example, if we start from the Praveena node and want to return the paths that contain alternating `Field` and `DevRel` nodes, we can specify a label filter of `"+Field,+DevRel"`.

.The following returns the paths of 1 to 4 hops from Praveena where the nodes alternate between having the `Field` and `DevRel` labels.
[source,cypher]
----
MATCH (p:Person {name: "Praveena"})
CALL apoc.path.expandConfig(p, {
	labelFilter: "+Field,+DevRel",
	beginSequenceAtStart: false,
	minLevel: 1,
	maxLevel: 4
})
YIELD path
RETURN path, length(path) AS hops
ORDER BY hops;
----

.Results
[opts="header"]
|===
| path | hops
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})                                                                                          | 1
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})                                                                                          | 1
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})                                              | 2
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})                                              | 2
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})-[:FOLLOWS]->(:Person:Field {name: "Stefan"}) | 3
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})-[:FOLLOWS]->(:Person:Field {name: "Stefan"}) | 3
|===

The `minLevel` and `maxLevel` values refer to the number of relationships in the path.
Using a `minLevel` of 1 means that paths where the node one hop from Praveena has the `Field` label will be returned.
If we want to ensure that the label sequence defined in this `labelFilter` is matched at least once, we need to use a `minLevel` of `2`.

.The following returns the paths of 2 to 4 hops from Praveena where the nodes alternate between having the `Field` and `DevRel` labels.
[source,cypher]
----
MATCH (p:Person {name: "Praveena"})
CALL apoc.path.expandConfig(p, {
	labelFilter: "+Field,+DevRel",
	beginSequenceAtStart: false,
	minLevel: 2,
	maxLevel: 4
})
YIELD path
RETURN path, length(path) AS hops
ORDER BY hops;
----

.Results
[opts="header"]
|===
| path | hops
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})                                              | 2
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})                                              | 2
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})-[:FOLLOWS]->(:Person:Field {name: "Stefan"}) | 3
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})-[:FOLLOWS]->(:Person:Field {name: "Stefan"}) | 3
|===

The paths that only contain a relationship from Praveena to Joe have now been filtered out.

But what if we don't want to specify multiple labels exist, but instead want to find paths where a node doesn't have a label?
To find paths that contain alternating `Field` and not `Field` nodes, we can specify a label filter of `"+Field,-Field"`.

.The following returns the paths of 1 to 4 hops from Praveena where the nodes alternate between having the `Field` label and not having the `Field` label
[source,cypher]
----
MATCH (p:Person {name: "Praveena"})
CALL apoc.path.expandConfig(p, {
	labelFilter: "+Field,-Field",
	beginSequenceAtStart: false,
	minLevel: 2,
	maxLevel: 4
})
YIELD path
RETURN path, length(path) AS hops
ORDER BY hops;
----

.Results
[opts="header"]
|===
| path | hops
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:Engineering {name: "Zhen"})                                                                                        | 2
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})<-[:FOLLOWS]-(:Person:Engineering {name: "Praveena"})                                                                                    | 2
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})                                                                                             | 2
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})<-[:FOLLOWS]-(:Person:Product {name: "Alicia"})                                                                                          | 2
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:Engineering {name: "Zhen"})                                                                                        | 2
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:Engineering {name: "Praveena"})                                                                                    | 2
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})                                                                                             | 2
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})<-[:FOLLOWS]-(:Person:Product {name: "Alicia"})                                                                                          | 2
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:Engineering {name: "Zhen"})-[:KNOWS]->(:Person:Field {name: "Stefan"})                                             | 3
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})-[:FOLLOWS]->(:Person:Field {name: "Stefan"})                                                | 3
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:Engineering {name: "Zhen"})-[:KNOWS]->(:Person:Field {name: "Stefan"})                                             | 3
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})-[:FOLLOWS]->(:Person:Field {name: "Stefan"})                                                | 3
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:Engineering {name: "Zhen"})-[:KNOWS]->(:Person:Field {name: "Stefan"})<-[:FOLLOWS]-(:Person:DevRel {name: "Mark"}) | 4
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})-[:FOLLOWS]->(:Person:Field {name: "Stefan"})<-[:KNOWS]-(:Person:Engineering {name: "Zhen"}) | 4
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:Engineering {name: "Zhen"})-[:KNOWS]->(:Person:Field {name: "Stefan"})<-[:FOLLOWS]-(:Person:DevRel {name: "Mark"}) | 4
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})-[:FOLLOWS]->(:Person:Field {name: "Stefan"})<-[:KNOWS]-(:Person:Engineering {name: "Zhen"}) | 4
|===

We've got a lot more paths, with path lengths between 2 and 4 hops.
These paths have the following labels:

* 2 hops - `Field` -> Not `Field`
* 3 hops - `Field` -> Not `Field` -> `Field`
* 4 hops - `Field` -> Not `Field` -> `Field` -> Not `Field`

These paths are a bit difficult to read, so we can simplify the output by using the `nodes` function to just return the nodes.
We'll also filter the results so that we only return paths that match the complete `+Field,-Field` label filter.
We can do this by only returning paths of even length:

.The following returns nodes of paths of 1 to 4 hops from Praveena where the nodes alternate between having the `Field` label and not having the `Field` label
[source,cypher]
----
MATCH (p:Person {name: "Praveena"})
CALL apoc.path.expandConfig(p, {
	labelFilter: "+Field,-Field",
	beginSequenceAtStart: false,
	minLevel: 2,
	maxLevel: 4
})
YIELD path
WHERE length(path) % 2 = 0

// Remove the Praveena node from the returned path
RETURN nodes(path)[1..] AS nodes, length(path) AS hops

ORDER BY hops;
----

.Results
[opts="header"]
|===
| nodes | hops
| [(:Person:Field {name: "Joe"}), (:Person:Engineering {name: "Zhen"})]                                                                    | 2
| [(:Person:Field {name: "Joe"}), (:Person:Engineering {name: "Praveena"})]                                                                | 2
| [(:Person:Field {name: "Joe"}), (:Person:DevRel {name: "Mark"})]                                                                         | 2
| [(:Person:Field {name: "Joe"}), (:Person:Product {name: "Alicia"})]                                                                      | 2
| [(:Person:Field {name: "Joe"}), (:Person:Engineering {name: "Zhen"})]                                                                    | 2
| [(:Person:Field {name: "Joe"}), (:Person:Engineering {name: "Praveena"})]                                                                | 2
| [(:Person:Field {name: "Joe"}), (:Person:DevRel {name: "Mark"})]                                                                         | 2
| [(:Person:Field {name: "Joe"}), (:Person:Product {name: "Alicia"})]                                                                      | 2
| [(:Person:Field {name: "Joe"}), (:Person:Engineering {name: "Zhen"}), (:Person:Field {name: "Stefan"}), (:Person:DevRel {name: "Mark"})] | 4
| [(:Person:Field {name: "Joe"}), (:Person:DevRel {name: "Mark"}), (:Person:Field {name: "Stefan"}), (:Person:Engineering {name: "Zhen"})] | 4
| [(:Person:Field {name: "Joe"}), (:Person:Engineering {name: "Zhen"}), (:Person:Field {name: "Stefan"}), (:Person:DevRel {name: "Mark"})] | 4
| [(:Person:Field {name: "Joe"}), (:Person:DevRel {name: "Mark"}), (:Person:Field {name: "Stefan"}), (:Person:Engineering {name: "Zhen"})] | 4
|===

The `\*` character can be used as a wildcard in a node sequence to indicate that any label can appear in that position.
If we want to match a sequence of nodes with any label followed by one with the `DevRel` label, we can specify the label filter ``*,+DevRel`

.The following returns nodes of paths of 1 to 4 hops from Praveena where the nodes alternate between having any label and the `DevRel` label
[source,cypher]
----
MATCH (p:Person {name: "Praveena"})
CALL apoc.path.expandConfig(p, {
	labelFilter: "*,+DevRel",
	beginSequenceAtStart: false,
	minLevel: 2,
	maxLevel: 4
})
YIELD path
RETURN path, length(path) AS hops
ORDER BY hops;
----

.Results
[opts="header"]
|===
| path | hops
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})                                              | 2
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})                                              | 2
| (:Person:Engineering {name: "Praveena"})<-[:KNOWS]-(:Person:Engineering {name: "Zhen"})-[:KNOWS]->(:Person:DevRel {name: "Lju"})                                            | 2
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})-[:KNOWS]->(:Person:Product {name: "Jake"})   | 3
| (:Person:Engineering {name: "Praveena"})<-[:FOLLOWS]-(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})-[:FOLLOWS]->(:Person:Field {name: "Stefan"}) | 3
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})-[:KNOWS]->(:Person:Product {name: "Jake"})   | 3
| (:Person:Engineering {name: "Praveena"})-[:FOLLOWS]->(:Person:Field {name: "Joe"})-[:FOLLOWS]->(:Person:DevRel {name: "Mark"})-[:FOLLOWS]->(:Person:Field {name: "Stefan"}) | 3
|===