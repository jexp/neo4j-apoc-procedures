[[path-expander-paths]]
== Expand paths


[source,cypher]
----
CALL apoc.path.expand(startNode <id>|Node, relationshipFilter, labelFilter, minLevel, maxLevel )

CALL apoc.path.expand(startNode <id>|Node|list, 'TYPE|TYPE_OUT>|<TYPE_IN', '+YesLabel|-NoLabel|/TerminationLabel|>EndNodeLabel', minLevel, maxLevel ) yield path
----

=== Relationship Filter

The syntax for relationship filters is described below:

include::relationship-filter.adoc[]

=== Label Filter

The syntax for label filters is described below:

include::label-filter.adoc[]


.Examples

[source,cypher]
----
call apoc.path.expand(1,"ACTED_IN>|PRODUCED<|FOLLOWS<","+Movie|Person",0,3)
call apoc.path.expand(1,"ACTED_IN>|PRODUCED<|FOLLOWS<","-BigBrother",0,3)
call apoc.path.expand(1,"ACTED_IN>|PRODUCED<|FOLLOWS<","",0,3)

// combined with cypher:

match (tom:Person {name :"Tom Hanks"})
call apoc.path.expand(tom,"ACTED_IN>|PRODUCED<|FOLLOWS<","+Movie|Person",0,3) yield path as pp
return pp;

// or

match (p:Person) with p limit 3
call apoc.path.expand(p,"ACTED_IN>|PRODUCED<|FOLLOWS<","+Movie|Person",1,2) yield path as pp
return p, pp
----

.Termination and end node label filter example

We will first set a `:Western` label on some nodes.

[source,cypher]
----
match (p:Person)
where p.name in ['Clint Eastwood', 'Gene Hackman']
set p:Western
----

Now expand from 'Keanu Reeves' to all `:Western` nodes with a termination filter:

[source,cypher]
----
match (k:Person {name:'Keanu Reeves'})
call apoc.path.expandConfig(k, {relationshipFilter:'ACTED_IN|PRODUCED|DIRECTED', labelFilter:'/Western', uniqueness: 'NODE_GLOBAL'}) yield path
return path
----

The one returned path only matches up to 'Gene Hackman'.
While there is a path from 'Keanu Reeves' to 'Clint Eastwood' through 'Gene Hackman', no further expansion is permitted through a node in the termination filter.

If you didn't want to stop expansion on reaching 'Gene Hackman', and wanted 'Clint Eastwood' returned as well, use the end node filter  instead (`>`).

.Label filter operator precedence and behavior

As of APOC 3.1.3.x, multiple label filter operators are allowed at the same time.

When processing the labelFilter string, once a filter operator is introduced, it remains the active filter until another filter supplants it.
(Not applicable after February 2018 release, as no filter will now mean the label is whitelisted).

In the following example, `:Person` and `:Movie` labels are whitelisted, `:SciFi` is blacklisted, with `:Western` acting as an end node label, and `:Romance` acting as a termination label.

`... labelFilter:'+Person|Movie|-SciFi|>Western|/Romance' ...`

The precedence of operator evaluation isn't dependent upon their location in the labelFilter but is fixed:

Blacklist filter `-`, termination filter `/`, end node filter `>`, whitelist filter `+`.

The consequences are as follows:

* No blacklisted label `-` will ever be present in the nodes of paths returned, no matter if the same label (or another label of a node with a blacklisted label) is included in another filter list.
* If the termination filter `/` or end node filter `>` is used, then only paths up to nodes with those labels will be returned as results. These end nodes are exempt from the whitelist filter.
* If a node is a termination node `/`, no further expansion beyond the node will occur.
* If a node is an end node `>`, expansion beyond that node will only occur if the end node has a label in the whitelist. This is to prevent returning paths to nodes where a node on that path violates the whitelist.
(this no longer applies in releases after February 2018)
* The whitelist only applies to nodes up to but not including end nodes from the termination or end node filters. If no end node or termination node operators are present, then the whitelist applies to all nodes of the path.
* If no whitelist operators are present in the labelFilter, this is treated as if all labels are whitelisted.
* If `filterStartNode` is false (which will be default in APOC 3.2.x.x), then the start node is exempt from the label filter.


=== Sequences

Introduced in the February 2018 APOC releases, path expander procedures can expand on repeating sequences of labels, relationship types, or both.

If only using label sequences, just use the `labelFilter`, but use commas to separate the filtering for each step in the repeating sequence.

If only using relationship sequences, just use the `relationshipFilter`, but use commas to separate the filtering for each step of the repeating sequence.

If using sequences of both relationships and labels, use the `sequence` parameter.

[opts=header,cols="a, m,a,m,a"]
|===
| Usage | config param | description | syntax | explanation
| label sequences only | labelFilter | Same syntax and filters, but uses commas (`,`) to separate the filters for each step in the sequence. |
 labelFilter:'Post\|-Blocked,Reply,>Admin' | Start node must be a :Post node that isn't :Blocked, next node must be a :Reply, and the next must be an :Admin, then repeat if able. Only paths ending with the `:Admin` node in that position of the sequence will be returned.
| relationship sequences only | relationshipFilter | Same syntax, but uses commas (`,`) to separate the filters for each relationship traversal in the sequence. |
relationshipFilter:'NEXT>,<FROM,POSTED>\|REPLIED>' | Expansion will first expand `NEXT>` from the start node, then `<FROM`, then either `POSTED>` or `REPLIED>`, then repeat if able.
| sequences of both labels and relationships | sequence | A string of comma-separated alternating label and relationship filters, for each step in a repeating sequence. The sequence should begin with a label filter, and end with a relationship filter. If present, `labelFilter`, and `relationshipFilter` are ignored, as this takes priority. |
sequence:'Post\|-Blocked, NEXT>, Reply, <FROM, >Admin, POSTED>\|REPLIED>'  | Combines the behaviors above.
|===


==== Starting the sequence at one-off from the start node

There are some uses cases where the sequence does not begin at the start node, but at one node distant.

A new config parameter, `beginSequenceAtStart`, can toggle this behavior.

Default value is `true`.

If set to `false`, this changes the expected values for `labelFilter`, `relationshipFilter`, and `sequence` as noted below:


[opts=header,cols="m,a,m,a"]
|===
| sequence | altered behavior | example | explanation
| labelFilter | The start node is not considered part of the sequence. The sequence begins one node off from the start node. |
beginSequenceAtStart:false, labelFilter:'Post\|-Blocked,Reply,>Admin' | The next node(s) out from the start node begins the sequence (and must be a :Post node that isn't :Blocked), and only paths ending with `Admin` nodes returned.
| relationshipFilter | The first relationship filter in the sequence string will not be considered part of the repeating sequence, and will only be used for the first relationship from the start node to the node that will be the actual start of the sequence. |
beginSequenceAtStart:false, relationshipFilter:'FIRST>,NEXT>,<FROM,POSTED>\|REPLIED>' | `FIRST>` will be traversed just from the start node to the node that will be the start of the repeating `NEXT>,<FROM,POSTED>\|REPLIED>` sequence.
| sequence | Combines the above two behaviors. |
beginSequenceAtStart:false, sequence:'FIRST>, Post\|-Blocked, NEXT>, Reply, <FROM, >Admin, POSTED>\|REPLIED>' | Combines the behaviors above.
|===

.Sequence tips

Label filtering in sequences work together with the `endNodes`+`terminatorNodes`, though inclusion of a node must be unanimous.

Remember that `filterStartNode` defaults to `false` for APOC 3.2.x.x and newer. If you want the start node filtered according to the first step in the sequence, you may need to set this explicitly to `true`.

If you need to limit the number of times a sequence repeats, this can be done with the `maxLevel` config param (multiply the number of iterations with the size of the nodes in the sequence).

As paths are important when expanding sequences, we recommend avoiding `apoc.path.subgraphNodes()`, `apoc.path.subgraphAll()`, and `apoc.path.spanningTree()` when using sequences,
as the configurations that make these efficient at matching to distinct nodes may interfere with sequence pathfinding.


//The examples in this section are based on the following sample graph:
//
//[source,cypher]
//----
//MERGE (mark:Person:DevRel {name: "Mark"})
//MERGE (praveena:Person:Engineering {name: "Praveena"})
//MERGE (joe:Person:Field {name: "Joe"})
//MERGE (lju:Person:DevRel {name: "Lju"})
//MERGE (zhen:Person:Engineering {name: "Zhen"})
//MERGE (stefan:Person:Field {name: "Stefan"})
//MERGE (alicia:Person:Product {name: "Alicia"})
//MERGE (martin:Person:Engineering {name: "Martin"})
//
//MERGE (alicia)-[:FOLLOWS]->(joe)
//MERGE (joe)-[:FOLLOWS]->(mark)
//MERGE (mark)-[:FOLLOWS]->(stefan)
//MERGE (zhen)-[:KNOWS]-(stefan)
//MERGE (zhen)-[:KNOWS]-(lju)
//MERGE (zhen)-[:KNOWS]-(praveena)
//MERGE (stefan)-[:FOLLOWS]->(joe)
//MERGE (praveena)-[:FOLLOWS]->(joe)
//MERGE (zhen)-[:KNOWS]-(martin)
//----
//
//
//[source,cypher]
//----
//MATCH (p:Person {name: "Praveena"})
//CALL apoc.path.expand(p, "KNOWS", null, 1, 3)
//YIELD path
//RETURN path, length(path) AS hops
//ORDER BY hops
//----
//
//
//.Results
//[opts="header"]
//|===
//| path | hops
//| (:Person:Engineering {name: "Praveena"})<-[:KNOWS]-(:Person:Engineering {name: "Zhen"})                                                  | 1
//| (:Person:Engineering {name: "Praveena"})<-[:KNOWS]-(:Person:Engineering {name: "Zhen"})-[:KNOWS]->(:Person:Engineering {name: "Martin"}) | 2
//| (:Person:Engineering {name: "Praveena"})<-[:KNOWS]-(:Person:Engineering {name: "Zhen"})-[:KNOWS]->(:Person:DevRel {name: "Lju"})         | 2
//| (:Person:Engineering {name: "Praveena"})<-[:KNOWS]-(:Person:Engineering {name: "Zhen"})-[:KNOWS]->(:Person:Field {name: "Stefan"})       | 2    |===
//
//[source,cypher]
//----
//MATCH (p:Person {name: "Praveena"})
//CALL apoc.path.expand(p, "KNOWS", "+Engineering", 1, 3)
//YIELD path
//RETURN path, length(path) AS hops
//ORDER BY hops
//----
