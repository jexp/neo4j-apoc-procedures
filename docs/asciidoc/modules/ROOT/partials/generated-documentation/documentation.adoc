== apoc.agg

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.agg.first**

apoc.agg.first(value) - returns first value|function|core
|**apoc.agg.graph**

apoc.agg.graph(path) - returns map of graph {nodes, relationships} of all distinct nodes and relationships|function|core
|**apoc.agg.last**

apoc.agg.last(value) - returns last value|function|core
|**apoc.agg.maxItems**

apoc.agg.maxItems(item, value, groupLimit: -1) - returns a map {items:[], value:n} where `value` is the maximum value present, and `items` are all items with the same value. The number of items can be optionally limited.|function|core
|**apoc.agg.median**

apoc.agg.median(number) - returns median for non-null numeric values|function|core
|**apoc.agg.minItems**

apoc.agg.minItems(item, value, groupLimit: -1) - returns a map {items:[], value:n} where `value` is the minimum value present, and `items` are all items with the same value. The number of items can be optionally limited.|function|core
|**apoc.agg.nth**

apoc.agg.nth(value,offset) - returns value of nth row (or -1 for last)|function|core
|**apoc.agg.percentiles**

apoc.agg.percentiles(value,[percentiles = 0.5,0.75,0.9,0.95,0.99]) - returns given percentiles for values|function|core
|**apoc.agg.product**

apoc.agg.product(number) - returns given product for non-null values|function|core
|**apoc.agg.slice**

apoc.agg.slice(value, start, length) - returns subset of non-null values, start is 0 based and length can be -1|function|core
|**apoc.agg.statistics**

apoc.agg.statistics(value,[percentiles = 0.5,0.75,0.9,0.95,0.99]) - returns numeric statistics (percentiles, min,minNonZero,max,total,mean,stdev) for values|function|core
|===

== apoc.algo

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::algorithms/path-finding-procedures.adoc[apoc.algo.aStar icon:book[]]

apoc.algo.aStar(startNode, endNode, 'KNOWS\|<WORKS_WITH\|IS_MANAGER_OF>', 'distance','lat','lon') YIELD path, weight - run A* with relationship property name as cost function|procedure|core
|xref::algorithms/path-finding-procedures.adoc[apoc.algo.aStarConfig icon:book[]]

apoc.algo.aStar(startNode, endNode, 'KNOWS\|<WORKS_WITH\|IS_MANAGER_OF>', {weight:'dist',default:10,x:'lon',y:'lat'}) YIELD path, weight - run A* with relationship property name as cost function|procedure|core
|xref::algorithms/path-finding-procedures.adoc[apoc.algo.allSimplePaths icon:book[]]

apoc.algo.allSimplePaths(startNode, endNode, 'KNOWS\|<WORKS_WITH\|IS_MANAGER_OF>', 5) YIELD path, weight - run allSimplePaths with relationships given and maxNodes|procedure|core
|xref::algorithms/path-finding-procedures.adoc[apoc.algo.cover icon:book[]]

apoc.algo.cover(nodes) yield rel - returns all relationships between this set of nodes|procedure|core
|xref::algorithms/path-finding-procedures.adoc[apoc.algo.dijkstra icon:book[]]

apoc.algo.dijkstra(startNode, endNode, 'KNOWS\|<WORKS_WITH\|IS_MANAGER_OF>', 'distance', defaultValue, numberOfWantedResults) YIELD path, weight - run dijkstra with relationship property name as cost function|procedure|core
|xref::algorithms/path-finding-procedures.adoc[apoc.algo.dijkstraWithDefaultWeight icon:book[]]

apoc.algo.dijkstraWithDefaultWeight(startNode, endNode, 'KNOWS\|<WORKS_WITH\|IS_MANAGER_OF>', 'distance', 10) YIELD path, weight - run dijkstra with relationship property name as cost function and a default weight if the property does not exist|procedure|core
|===

[discrete]
== apoc.any

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-querying/node-querying.adoc[apoc.any.properties icon:book[]]

returns properties for virtual and real, nodes, rels and maps|function|core
|xref::graph-querying/node-querying.adoc[apoc.any.property icon:book[]]

returns property for virtual and real, nodes, rels and maps|function|core
|===

== apoc.atomic

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-updates/atomic-updates.adoc[apoc.atomic.add icon:book[]]

apoc.atomic.add(node/relatonship,propertyName,number) Sums the property's value with the 'number' value |procedure|core
|xref::graph-updates/atomic-updates.adoc[apoc.atomic.concat icon:book[]]

apoc.atomic.concat(node/relatonship,propertyName,string) Concats the property's value with the 'string' value|procedure|core
|xref::graph-updates/atomic-updates.adoc[apoc.atomic.insert icon:book[]]

apoc.atomic.insert(node/relatonship,propertyName,position,value) insert a value into the property's array value at 'position'|procedure|core
|xref::graph-updates/atomic-updates.adoc[apoc.atomic.remove icon:book[]]

apoc.atomic.remove(node/relatonship,propertyName,position) remove the element at position 'position'|procedure|core
|xref::graph-updates/atomic-updates.adoc[apoc.atomic.subtract icon:book[]]

apoc.atomic.subtract(node/relatonship,propertyName,number) Subtracts the 'number' value to the property's value|procedure|core
|xref::graph-updates/atomic-updates.adoc[apoc.atomic.update icon:book[]]

apoc.atomic.update(node/relatonship,propertyName,updateOperation) update a property's value with a cypher operation (ex. "n.prop1+n.prop2")|procedure|core
|===

[discrete]
== apoc.bitwise

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.bitwise.op**

apoc.bitwise.op(60,'\|',13) bitwise operations a & b, a \| b, a ^ b, ~a, a >> b, a >>> b, a << b. returns the result of the bitwise operation|function|core
|===

[discrete]
== apoc.bolt

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::database-integration/bolt-neo4j.adoc[apoc.bolt.execute icon:book[]]

apoc.bolt.execute(url-or-key, kernelTransaction, params, config) - access to other databases via bolt for read|procedure|full
|xref::database-integration/bolt-neo4j.adoc[apoc.bolt.load icon:book[]]

apoc.bolt.load(url-or-key, kernelTransaction, params, config) - access to other databases via bolt for read|procedure|full
|===

[discrete]
== apoc.cluster

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.cluster.graph**

|procedure|full
|===

== apoc.coll

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::data-structures/collection-list-functions.adoc[apoc.coll.elements icon:book[]]

apoc.coll.elements(list,limit,offset) yield _1,_2,..,_10,_1s,_2i,_3f,_4m,_5l,_6n,_7r,_8p - deconstruct subset of mixed list into identifiers of the correct type|procedure|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.partition icon:book[]]

apoc.coll.partition(list,batchSize)|procedure|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.split icon:book[]]

apoc.coll.split(list,value) \| splits collection on given values rows of lists, value itself will not be part of resulting lists|procedure|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.zipToRows icon:book[]]

apoc.coll.zipToRows(list1,list2) - creates pairs like zip but emits one row per pair|procedure|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.avg icon:book[]]

apoc.coll.avg([0.5,1,2.3])|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.combinations icon:book[]]

apoc.coll.combinations(coll, minSelect, maxSelect:minSelect) - Returns collection of all combinations of list elements of selection size between minSelect and maxSelect (default:minSelect), inclusive|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.contains icon:book[]]

apoc.coll.contains(coll, value) optimized contains operation (using a HashSet) (returns single row or not)|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.containsAll icon:book[]]

apoc.coll.containsAll(coll, values) optimized contains-all operation (using a HashSet) (returns single row or not)|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.containsAllSorted icon:book[]]

apoc.coll.containsAllSorted(coll, value) optimized contains-all on a sorted list operation (Collections.binarySearch) (returns single row or not)|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.containsDuplicates icon:book[]]

apoc.coll.containsDuplicates(coll) - returns true if a collection contains duplicate elements|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.containsSorted icon:book[]]

apoc.coll.containsSorted(coll, value) optimized contains on a sorted list operation (Collections.binarySearch) (returns single row or not)|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.different icon:book[]]

apoc.coll.different(values) - returns true if values are different|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.disjunction icon:book[]]

apoc.coll.disjunction(first, second) - returns the disjunct set of the two lists|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.dropDuplicateNeighbors icon:book[]]

apoc.coll.dropDuplicateNeighbors(list) - remove duplicate consecutive objects in a list|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.duplicates icon:book[]]

apoc.coll.duplicates(coll) - returns a list of duplicate items in the collection|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.duplicatesWithCount icon:book[]]

apoc.coll.duplicatesWithCount(coll) - returns a list of duplicate items in the collection and their count, keyed by `item` and `count` (e.g., `[{item: xyz, count:2}, {item:zyx, count:5}]`)|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.fill icon:book[]]

apoc.coll.fill(item, count) - returns a list with the given count of items|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.flatten icon:book[]]

apoc.coll.flatten(coll, [recursive]) - flattens list (nested if recursive is true)|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.frequencies icon:book[]]

apoc.coll.frequencies(coll) - returns a list of frequencies of the items in the collection, keyed by `item` and `count` (e.g., `[{item: xyz, count:2}, {item:zyx, count:5}, {item:abc, count:1}]`)|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.frequenciesAsMap icon:book[]]

apoc.coll.frequenciesAsMap(coll) - return a map of frequencies of the items in the collection, key `item`, value `count` (e.g., `{1:2, 2:1}`)|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.indexOf icon:book[]]

apoc.coll.indexOf(coll, value) \| position of value in the list|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.insert icon:book[]]

apoc.coll.insert(coll, index, value) \| insert value at index|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.insertAll icon:book[]]

apoc.coll.insertAll(coll, index, values) \| insert values at index|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.intersection icon:book[]]

apoc.coll.intersection(first, second) - returns the unique intersection of the two lists|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.isEqualCollection icon:book[]]

apoc.coll.isEqualCollection(coll, values) return true if two collections contain the same elements with the same cardinality in any order (using a HashMap)|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.max icon:book[]]

apoc.coll.max([0.5,1,2.3])|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.min icon:book[]]

apoc.coll.min([0.5,1,2.3])|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.occurrences icon:book[]]

apoc.coll.occurrences(coll, item) - returns the count of the given item in the collection|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.pairs icon:book[]]

apoc.coll.pairs([1,2,3]) returns [1,2],[2,3],[3,null] |function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.pairsMin icon:book[]]

apoc.coll.pairsMin([1,2,3]) returns [1,2],[2,3]|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.partition icon:book[]]

apoc.coll.partition(list,batchSize)|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.randomItem icon:book[]]

apoc.coll.randomItem(coll)- returns a random item from the list, or null on an empty or null list|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.randomItems icon:book[]]

apoc.coll.randomItems(coll, itemCount, allowRepick: false) - returns a list of itemCount random items from the original list, optionally allowing picked elements to be picked again|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.remove icon:book[]]

apoc.coll.remove(coll, index, [length=1]) \| remove range of values from index to length|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.removeAll icon:book[]]

apoc.coll.removeAll(first, second) - returns first list with all elements of second list removed|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.reverse icon:book[]]

apoc.coll.reverse(coll) - returns reversed list|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.set icon:book[]]

apoc.coll.set(coll, index, value) \| set index to value|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.shuffle icon:book[]]

apoc.coll.shuffle(coll) - returns the shuffled list|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.sort icon:book[]]

apoc.coll.sort(coll) sort on Collections|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.sortMaps icon:book[]]

apoc.coll.sortMaps([maps], 'name') - sort maps by property|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.sortMulti icon:book[]]

apoc.coll.sortMulti(coll, ['^name','age'],[limit],[skip]) - sort list of maps by several sort fields (ascending with ^ prefix) and optionally applies limit and skip|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.sortNodes icon:book[]]

apoc.coll.sortNodes([nodes], 'name') sort nodes by property|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.sortText icon:book[]]

apoc.coll.sortText(coll) sort on string based collections|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.subtract icon:book[]]

apoc.coll.subtract(first, second) - returns unique set of first list with all elements of second list removed|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.sum icon:book[]]

apoc.coll.sum([0.5,1,2.3])|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.sumLongs icon:book[]]

apoc.coll.sumLongs([1,3,3])|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.toSet icon:book[]]

apoc.coll.toSet([list]) returns a unique list backed by a set|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.union icon:book[]]

apoc.coll.union(first, second) - creates the distinct union of the 2 lists|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.unionAll icon:book[]]

apoc.coll.unionAll(first, second) - creates the full union with duplicates of the two lists|function|core
|xref::data-structures/collection-list-functions.adoc[apoc.coll.zip icon:book[]]

apoc.coll.zip([list1],[list2])|function|core
|===

[discrete]
== apoc.config

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::database-introspection/config.adoc[apoc.config.list icon:book[]]

apoc.config.list \| Lists the Neo4j configuration as key,value table|procedure|full
|xref::database-introspection/config.adoc[apoc.config.map icon:book[]]

apoc.config.map \| Lists the Neo4j configuration as map|procedure|full
|===

== apoc.convert

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::data-structures/conversion-functions.adoc[apoc.convert.setJsonProperty icon:book[]]

apoc.convert.setJsonProperty(node,key,complexValue) - sets value serialized to JSON as property with the given name on the node|procedure|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toTree icon:book[]]

apoc.convert.toTree([paths],[lowerCaseRels=true], [config]) creates a stream of nested documents representing the at least one root of these paths|procedure|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.fromJsonList icon:book[]]

apoc.convert.fromJsonList('[1,2,3]'[,'json-path'])|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.fromJsonMap icon:book[]]

apoc.convert.fromJsonMap('{"a":42,"b":"foo","c":[1,2,3]}'[,'json-path'])|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.getJsonProperty icon:book[]]

apoc.convert.getJsonProperty(node,key[,'json-path']) - converts serialized JSON in property back to original object|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.getJsonPropertyMap icon:book[]]

apoc.convert.getJsonPropertyMap(node,key[,'json-path']) - converts serialized JSON in property back to map|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toBoolean icon:book[]]

apoc.convert.toBoolean(value) \| tries it's best to convert the value to a boolean|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toBooleanList icon:book[]]

apoc.convert.toBooleanList(value) \| tries it's best to convert the value to a list of booleans|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toFloat icon:book[]]

apoc.convert.toFloat(value) \| tries it's best to convert the value to a float|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toIntList icon:book[]]

apoc.convert.toIntList(value) \| tries it's best to convert the value to a list of integers|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toInteger icon:book[]]

apoc.convert.toInteger(value) \| tries it's best to convert the value to an integer|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toJson icon:book[]]

apoc.convert.toJson([1,2,3]) or toJson({a:42,b:"foo",c:[1,2,3]})|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toList icon:book[]]

apoc.convert.toList(value) \| tries it's best to convert the value to a list|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toMap icon:book[]]

apoc.convert.toMap(value) \| tries it's best to convert the value to a map|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toNode icon:book[]]

apoc.convert.toNode(value) \| tries it's best to convert the value to a node|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toNodeList icon:book[]]

apoc.convert.toNodeList(value) \| tries it's best to convert the value to a list of nodes|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toRelationship icon:book[]]

apoc.convert.toRelationship(value) \| tries it's best to convert the value to a relationship|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toRelationshipList icon:book[]]

apoc.convert.toRelationshipList(value) \| tries it's best to convert the value to a list of relationships|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toSet icon:book[]]

apoc.convert.toSet(value) \| tries it's best to convert the value to a set|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toSortedJsonMap icon:book[]]

apoc.convert.toSortedJsonMap(node\|map, ignoreCase:true) - returns a JSON map with keys sorted alphabetically, with optional case sensitivity|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toString icon:book[]]

apoc.convert.toString(value) \| tries it's best to convert the value to a string|function|core
|xref::data-structures/conversion-functions.adoc[apoc.convert.toStringList icon:book[]]

apoc.convert.toStringList(value) \| tries it's best to convert the value to a list of strings|function|core
|===

== apoc.couchbase

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::database-integration/couchbase.adoc[apoc.couchbase.append icon:book[]]

apoc.couchbase.append(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - append a couchbase json document to an existing one.|procedure|full
|xref::database-integration/couchbase.adoc[apoc.couchbase.exists icon:book[]]

apoc.couchbase.exists(hostOrKey, bucket, documentId) yield value - check whether a couchbase json document with the given ID does exist.|procedure|full
|xref::database-integration/couchbase.adoc[apoc.couchbase.get icon:book[]]

apoc.couchbase.get(hostOrKey, bucket, documentId) yield id, expiry, cas, mutationToken, content - retrieves a couchbase json document by its unique ID.|procedure|full
|xref::database-integration/couchbase.adoc[apoc.couchbase.insert icon:book[]]

apoc.couchbase.insert(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert a couchbase json document with its unique ID.|procedure|full
|xref::database-integration/couchbase.adoc[apoc.couchbase.namedParamsQuery icon:book[]]

apoc.couchbase.namedParamsQuery(hostkOrKey, bucket, statement, paramNames, paramValues) yield queryResult - executes a N1QL statement with named parameters.|procedure|full
|xref::database-integration/couchbase.adoc[apoc.couchbase.posParamsQuery icon:book[]]

apoc.couchbase.posParamsQuery(hostOrKey, bucket, statement, params) yield queryResult - executes a N1QL statement with positional parameters.|procedure|full
|xref::database-integration/couchbase.adoc[apoc.couchbase.prepend icon:book[]]

apoc.couchbase.prepend(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - prepend a couchbase json document to an existing one.|procedure|full
|xref::database-integration/couchbase.adoc[apoc.couchbase.query icon:book[]]

apoc.couchbase.query(hostOrKey, bucket, statement) yield queryResult - executes a plain un-parameterized N1QL statement.|procedure|full
|xref::database-integration/couchbase.adoc[apoc.couchbase.remove icon:book[]]

apoc.couchbase.remove(hostOrKey, bucket, documentId) yield id, expiry, cas, mutationToken, content - remove the couchbase json document identified by its unique ID.|procedure|full
|xref::database-integration/couchbase.adoc[apoc.couchbase.replace icon:book[]]

apoc.couchbase.replace(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - replace the content of the couchbase json document identified by its unique ID.|procedure|full
|xref::database-integration/couchbase.adoc[apoc.couchbase.upsert icon:book[]]

apoc.couchbase.upsert(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert or overwrite a couchbase json document with its unique ID.|procedure|full
|===

== apoc.create

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-updates/data-creation.adoc[apoc.create.addLabels icon:book[]]

apoc.create.addLabels( [node,id,ids,nodes], ['Label',...]) - adds the given labels to the node or nodes|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.create.node icon:book[]]

apoc.create.node(['Label'], {key:value,...}) - create node with dynamic labels|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.create.nodes icon:book[]]

apoc.create.nodes(['Label'], [{key:value,...}]) create multiple nodes with dynamic labels|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.create.relationship icon:book[]]

apoc.create.relationship(person1,'KNOWS',{key:value,...}, person2) create relationship with dynamic rel-type|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.create.removeLabels icon:book[]]

apoc.create.removeLabels( [node,id,ids,nodes], ['Label',...]) - removes the given labels from the node or nodes|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.create.removeProperties icon:book[]]

apoc.create.removeProperties( [node,id,ids,nodes], [keys]) - removes the given properties from the nodes(s)|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.create.removeRelProperties icon:book[]]

apoc.create.removeRelProperties( [rel,id,ids,rels], [keys]) - removes the given properties from the relationship(s)|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.create.setLabels icon:book[]]

apoc.create.setLabels( [node,id,ids,nodes], ['Label',...]) - sets the given labels, non matching labels are removed on the node or nodes|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.create.setProperties icon:book[]]

apoc.create.setProperties( [node,id,ids,nodes], [keys], [values]) - sets the given properties on the nodes(s)|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.create.setProperty icon:book[]]

apoc.create.setProperty( [node,id,ids,nodes], key, value) - sets the given property on the node(s)|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.create.setRelProperties icon:book[]]

apoc.create.setRelProperties( [rel,id,ids,rels], [keys], [values]) - sets the given properties on the relationship(s)|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.create.setRelProperty icon:book[]]

apoc.create.setRelProperty( [rel,id,ids,rels], key, value) - sets the given property on the relationship(s)|procedure|core
|**apoc.create.uuids**

apoc.create.uuids(count) yield uuid - creates 'count' UUIDs |procedure|core
|xref::virtual/virtual-nodes-rels.adoc[apoc.create.vNode icon:book[]]

apoc.create.vNode(['Label'], {key:value,...}) returns a virtual node|procedure|core
|xref::virtual/virtual-nodes-rels.adoc[apoc.create.vNodes icon:book[]]

apoc.create.vNodes(['Label'], [{key:value,...}]) returns virtual nodes|procedure|core
|xref::virtual/virtual-nodes-rels.adoc[apoc.create.vPattern icon:book[]]

apoc.create.vPattern({_labels:['LabelA'],key:value},'KNOWS',{key:value,...}, {_labels:['LabelB'],key:value}) returns a virtual pattern|procedure|core
|xref::virtual/virtual-nodes-rels.adoc[apoc.create.vPatternFull icon:book[]]

apoc.create.vPatternFull(['LabelA'],{key:value},'KNOWS',{key:value,...},['LabelB'],{key:value}) returns a virtual pattern|procedure|core
|xref::virtual/virtual-nodes-rels.adoc[apoc.create.vRelationship icon:book[]]

apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,...}, nodeTo) returns a virtual relationship|procedure|core
|xref::graph-updates/uuid.adoc[apoc.create.uuid icon:book[]]

apoc.create.uuid() - creates an UUID|function|core
|xref::virtual/virtual-nodes-rels.adoc[apoc.create.vNode icon:book[]]

apoc.create.vNode(['Label'], {key:value,...}) returns a virtual node|function|core
|xref::virtual/virtual-nodes-rels.adoc[apoc.create.vRelationship icon:book[]]

apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,...}, nodeTo) returns a virtual relationship|function|core
|===

== apoc.custom

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::cypher-execution/cypher-based-procedures-functions.adoc[apoc.custom.asFunction icon:book[]]

apoc.custom.asFunction(name, statement, outputs, inputs, forceSingle, description) - register a custom cypher function|procedure|full
|xref::cypher-execution/cypher-based-procedures-functions.adoc[apoc.custom.asProcedure icon:book[]]

apoc.custom.asProcedure(name, statement, mode, outputs, inputs, description) - register a custom cypher procedure|procedure|full
|xref::cypher-execution/cypher-based-procedures-functions.adoc[apoc.custom.declareFunction icon:book[]]

apoc.custom.declareFunction(signature, statement, forceSingle, description) - register a custom cypher function|procedure|full
|xref::cypher-execution/cypher-based-procedures-functions.adoc[apoc.custom.declareProcedure icon:book[]]

apoc.custom.declareProcedure(signature, statement, mode, description) - register a custom cypher procedure|procedure|full
|xref::cypher-execution/cypher-based-procedures-functions.adoc[apoc.custom.list icon:book[]]

apoc.custom.list() - provide a list of custom procedures/function registered|procedure|full
|xref::cypher-execution/cypher-based-procedures-functions.adoc[apoc.custom.removeFunction icon:book[]]

apoc.custom.removeFunction(name, type) - remove the targeted custom function|procedure|full
|xref::cypher-execution/cypher-based-procedures-functions.adoc[apoc.custom.removeProcedure icon:book[]]

apoc.custom.removeProcedure(name) - remove the targeted custom procedure|procedure|full
|===

== apoc.cypher

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::cypher-execution/index.adoc[apoc.cypher.doIt icon:book[]]

apoc.cypher.doIt(fragment, params) yield value - executes writing fragment with the given parameters|procedure|core
|xref::cypher-execution/index.adoc[apoc.cypher.mapParallel icon:book[]]

apoc.cypher.mapParallel(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _|procedure|full
|xref::cypher-execution/index.adoc[apoc.cypher.mapParallel2 icon:book[]]

apoc.cypher.mapParallel2(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _|procedure|full
|xref::cypher-execution/index.adoc[apoc.cypher.parallel icon:book[]]

|procedure|full
|xref::cypher-execution/index.adoc[apoc.cypher.parallel2 icon:book[]]

|procedure|full
|xref::cypher-execution/index.adoc[apoc.cypher.run icon:book[]]

apoc.cypher.run(fragment, params) yield value - executes reading fragment with the given parameters|procedure|core
|xref::cypher-execution/index.adoc[apoc.cypher.runFile icon:book[]]

apoc.cypher.runFile(file or url,[{statistics:true,timeout:10,parameters:{}}]) - runs each statement in the file, all semicolon separated - currently no schema operations|procedure|full
|xref::cypher-execution/index.adoc[apoc.cypher.runFiles icon:book[]]

apoc.cypher.runFiles([files or urls],[{statistics:true,timeout:10,parameters:{}}])) - runs each statement in the files, all semicolon separated|procedure|full
|xref::cypher-execution/index.adoc[apoc.cypher.runMany icon:book[]]

apoc.cypher.runMany('cypher;\nstatements;',{params},[{statistics:true,timeout:10}]) - runs each semicolon separated statement and returns summary - currently no schema operations|procedure|core
|xref::cypher-execution/index.adoc[apoc.cypher.runSchemaFile icon:book[]]

apoc.cypher.runSchemaFile(file or url,[{statistics:true,timeout:10}]) - allows only schema operations, runs each schema statement in the file, all semicolon separated|procedure|full
|xref::cypher-execution/index.adoc[apoc.cypher.runSchemaFiles icon:book[]]

apoc.cypher.runSchemaFiles([files or urls],{statistics:true,timeout:10}) - allows only schema operations, runs each schema statement in the files, all semicolon separated|procedure|full
|xref::cypher-execution/index.adoc[apoc.cypher.runTimeboxed icon:book[]]

apoc.cypher.runTimeboxed('cypherStatement',{params}, timeout) - abort kernelTransaction after timeout ms if not finished|procedure|core
|xref::cypher-execution/index.adoc[apoc.cypher.runFirstColumn icon:book[]]

use either apoc.cypher.runFirstColumnMany for a list return or apoc.cypher.runFirstColumnSingle for returning the first row of the first column|function|core
|xref::cypher-execution/index.adoc[apoc.cypher.runFirstColumnMany icon:book[]]

apoc.cypher.runFirstColumnMany(statement, params) - executes statement with given parameters, returns first column only collected into a list, params are available as identifiers|function|core
|xref::cypher-execution/index.adoc[apoc.cypher.runFirstColumnSingle icon:book[]]

apoc.cypher.runFirstColumnSingle(statement, params) - executes statement with given parameters, returns first element of the first column only, params are available as identifiers|function|core
|===

== apoc.data

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.data.domain**

apoc.data.domain('url_or_email_address') YIELD domain - extract the domain name from a url or an email address. If nothing was found, yield null.|function|core
|**apoc.data.email**

apoc.data.email('email_address') as {personal,user,domain} - extract the personal name, user and domain as a map|function|core
|**apoc.data.url**

apoc.data.url('url') as {protocol,host,port,path,query,file,anchor,user} \| turn URL into map structure|function|core
|===

== apoc.date

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::temporal/datetime-conversions.adoc[apoc.date.expire icon:book[]]

CALL apoc.date.expire(node,time,'time-unit') - expire node at specified time by setting :TTL label and `ttl` property|procedure|full
|xref::temporal/datetime-conversions.adoc[apoc.date.expireIn icon:book[]]

CALL apoc.date.expire.in(node,time,'time-unit') - expire node after specified length of time time by setting :TTL label and `ttl` property|procedure|full
|xref::temporal/datetime-conversions.adoc[apoc.date.add icon:book[]]

apoc.date.add(12345, 'ms', -365, 'd') given a timestamp in one time unit, adds a value of the specified time unit|function|core
|xref::temporal/datetime-conversions.adoc[apoc.date.convert icon:book[]]

apoc.date.convert(12345, 'ms', 'd') convert a timestamp in one time unit into one of a different time unit|function|core
|xref::temporal/datetime-conversions.adoc[apoc.date.convertFormat icon:book[]]

apoc.date.convertFormat('Tue, 14 May 2019 14:52:06 -0400', 'rfc_1123_date_time', 'iso_date_time') convert a String of one date format into a String of another date format.|function|core
|xref::temporal/datetime-conversions.adoc[apoc.date.currentTimestamp icon:book[]]

apoc.date.currentTimestamp() - returns System.currentTimeMillis()|function|core
|xref::temporal/datetime-conversions.adoc[apoc.date.field icon:book[]]

apoc.date.field(12345,('ms\|s\|m\|h\|d\|month\|year'),('TZ')|function|core
|xref::temporal/datetime-conversions.adoc[apoc.date.fields icon:book[]]

apoc.date.fields('2012-12-23',('yyyy-MM-dd')) - return columns and a map representation of date parsed with the given format with entries for years,months,weekdays,days,hours,minutes,seconds,zoneid|function|core
|xref::temporal/datetime-conversions.adoc[apoc.date.format icon:book[]]

apoc.date.format(12345,('ms\|s\|m\|h\|d'),('yyyy-MM-dd HH:mm:ss zzz'),('TZ')) get string representation of time value optionally using the specified unit (default ms) using specified format (default ISO) and specified time zone (default current TZ)|function|core
|xref::temporal/datetime-conversions.adoc[apoc.date.fromISO8601 icon:book[]]

apoc.date.fromISO8601('yyyy-MM-ddTHH:mm:ss.SSSZ') return number representation of time in EPOCH format|function|core
|xref::temporal/datetime-conversions.adoc[apoc.date.parse icon:book[]]

apoc.date.parse('2012-12-23','ms\|s\|m\|h\|d','yyyy-MM-dd') parse date string using the specified format into the specified time unit|function|core
|xref::temporal/datetime-conversions.adoc[apoc.date.parseAsZonedDateTime icon:book[]]

apoc.date.parseAsZonedDateTime('2012-12-23 23:59:59','yyyy-MM-dd HH:mm:ss', 'UTC-hour-offset') parse date string using the specified format to specified timezone|function|core
|xref::temporal/datetime-conversions.adoc[apoc.date.systemTimezone icon:book[]]

apoc.date.systemTimezone() returns the system timezone display name|function|core
|xref::temporal/datetime-conversions.adoc[apoc.date.toISO8601 icon:book[]]

apoc.date.toISO8601(12345,('ms\|s\|m\|h\|d') return string representation of time in ISO8601 format|function|core
|xref::temporal/datetime-conversions.adoc[apoc.date.toYears icon:book[]]

toYears(timestamp) or toYears(date[,format]) converts timestamp into floating point years|function|core
|===

[discrete]
== apoc.diff

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.diff.nodes**

|function|core
|===

[discrete]
== apoc.do

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::cypher-execution/conditionals.adoc[apoc.do.case icon:book[]]

apoc.do.case([condition, query, condition, query, ...], elseQuery:'', params:{}) yield value - given a list of conditional / writing query pairs, executes the query associated with the first conditional evaluating to true (or the else query if none are true) with the given parameters|procedure|core
|xref::cypher-execution/conditionals.adoc[apoc.do.when icon:book[]]

apoc.do.when(condition, ifQuery, elseQuery:'', params:{}) yield value - based on the conditional, executes writing ifQuery or elseQuery with the given parameters|procedure|core
|===

== apoc.es

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::database-integration/elasticsearch.adoc[apoc.es.get icon:book[]]

apoc.es.get(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a GET operation on elastic search|procedure|full
|xref::database-integration/elasticsearch.adoc[apoc.es.getRaw icon:book[]]

apoc.es.getRaw(host-or-port,path,payload-or-null) yield value - perform a raw GET operation on elastic search|procedure|full
|xref::database-integration/elasticsearch.adoc[apoc.es.post icon:book[]]

apoc.es.post(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a POST operation on elastic search|procedure|full
|xref::database-integration/elasticsearch.adoc[apoc.es.postRaw icon:book[]]

apoc.es.postRaw(host-or-port,path,payload-or-null) yield value - perform a raw POST operation on elastic search|procedure|full
|xref::database-integration/elasticsearch.adoc[apoc.es.put icon:book[]]

apoc.es.put(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a PUT operation on elastic search|procedure|full
|xref::database-integration/elasticsearch.adoc[apoc.es.query icon:book[]]

apoc.es.query(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a SEARCH operation on elastic search|procedure|full
|xref::database-integration/elasticsearch.adoc[apoc.es.stats icon:book[]]

apoc.es.stats(host-url-Key) - elastic search statistics|procedure|full
|===

[discrete]
== apoc.example

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.example.movies**

apoc.example.movies() \| Creates the sample movies graph|procedure|core
|===

== apoc.export

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::export/cypher.adoc[apoc.export.cypherAll icon:book[]]

apoc.export.cypherAll(file,config) - exports whole database incl. indexes as cypher statements to the provided file|procedure|core
|xref::export/cypher.adoc[apoc.export.cypherData icon:book[]]

apoc.export.cypherData(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file|procedure|core
|xref::export/cypher.adoc[apoc.export.cypherGraph icon:book[]]

apoc.export.cypherGraph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file|procedure|core
|xref::export/cypher.adoc[apoc.export.cypherQuery icon:book[]]

apoc.export.cypherQuery(query,file,config) - exports nodes and relationships from the cypher kernelTransaction incl. indexes as cypher statements to the provided file|procedure|core
|===

== apoc.generate

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-updates/graph-generators.adoc[apoc.generate.ba icon:book[]]

apoc.generate.ba(noNodes, edgesPerNode, label, type) - generates a random graph according to the Barabasi-Albert model|procedure|full
|xref::graph-updates/graph-generators.adoc[apoc.generate.complete icon:book[]]

apoc.generate.complete(noNodes, label, type) - generates a random complete graph|procedure|full
|xref::graph-updates/graph-generators.adoc[apoc.generate.er icon:book[]]

apoc.generate.er(noNodes, noEdges, label, type) - generates a random graph according to the Erdos-Renyi model|procedure|full
|xref::graph-updates/graph-generators.adoc[apoc.generate.simple icon:book[]]

apoc.generate.simple(degrees, label, type) - generates a simple random graph according to the given degree distribution|procedure|full
|xref::graph-updates/graph-generators.adoc[apoc.generate.ws icon:book[]]

apoc.generate.ws(noNodes, degree, beta, label, type) - generates a random graph according to the Watts-Strogatz model|procedure|full
|===

[discrete]
== apoc.gephi

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.gephi.add**

apoc.gephi.add(url-or-key, workspace, data, weightproperty, ['exportproperty']) \| streams passed in data to Gephi|procedure|full
|===

[discrete]
== apoc.get

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.get.nodes**

apoc.get.nodes(node\|id\|[ids]) - quickly returns all nodes with these id's|procedure|full
|**apoc.get.rels**

apoc.get.rels(rel\|id\|[ids]) - quickly returns all relationships with these id's|procedure|full
|===

== apoc.graph

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::export/gephi.adoc[apoc.graph.from icon:book[]]

apoc.graph.from(data,'name',{properties}) \| creates a virtual graph object for later processing it tries its best to extract the graph information from the data you pass in|procedure|core
|xref::export/gephi.adoc[apoc.graph.fromCypher icon:book[]]

apoc.graph.fromCypher('kernelTransaction',{params},'name',{properties}) - creates a virtual graph object for later processing|procedure|core
|xref::export/gephi.adoc[apoc.graph.fromDB icon:book[]]

apoc.graph.fromDB('name',{properties}) - creates a virtual graph object for later processing|procedure|core
|xref::export/gephi.adoc[apoc.graph.fromData icon:book[]]

apoc.graph.fromData([nodes],[relationships],'name',{properties}) \| creates a virtual graph object for later processing|procedure|core
|xref::export/gephi.adoc[apoc.graph.fromDocument icon:book[]]

apoc.graph.fromDocument({json}, {config}) yield graph - transform JSON documents into graph structures|procedure|core
|xref::export/gephi.adoc[apoc.graph.fromPath icon:book[]]

apoc.graph.fromPaths(path,'name',{properties}) - creates a virtual graph object for later processing|procedure|core
|xref::export/gephi.adoc[apoc.graph.fromPaths icon:book[]]

apoc.graph.fromPaths([paths],'name',{properties}) - creates a virtual graph object for later processing|procedure|core
|xref::export/gephi.adoc[apoc.graph.validateDocument icon:book[]]

apoc.graph.validateDocument({json}, {config}) yield row - validates the json, return the result of the validation|procedure|core
|===

== apoc.hashing

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::comparing-graphs/fingerprinting.adoc[apoc.hashing.fingerprint icon:book[]]

calculate a checksum (md5) over a node or a relationship. This deals gracefully with array properties. Two identical entities do share the same hash.|function|core
|xref::comparing-graphs/fingerprinting.adoc[apoc.hashing.fingerprintGraph icon:book[]]

calculate a checksum (md5) over a the full graph. Be aware that this function does use in-memomry datastructures depending on the size of your graph.|function|core
|xref::comparing-graphs/fingerprinting.adoc[apoc.hashing.fingerprinting icon:book[]]

calculate a checksum (md5) over a node or a relationship. This deals gracefully with array properties. Two identical entities do share the same hash.|function|core
|===

== apoc.import

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::import/import-csv.adoc[apoc.import.csv icon:book[]]

apoc.import.csv(nodes, relationships, config) - imports nodes and relationships from the provided CSV files with given labels and types|procedure|core
|xref::import/graphml.adoc[apoc.import.graphml icon:book[]]

apoc.import.graphml(file,config) - imports graphml file|procedure|core
|xref::import/load-json.adoc[apoc.import.json icon:book[]]

apoc.import.json(file,config) - imports the json list to the provided file|procedure|core
|xref::import/xml.adoc[apoc.import.xml icon:book[]]

apoc.import.xml(file,config) - imports graph from provided file|procedure|core
|===

[discrete]
== apoc.json

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.json.path**

apoc.json.path('{json}','json-path')|function|core
|===

[discrete]
== apoc.label

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-querying/node-querying.adoc[apoc.label.exists icon:book[]]

apoc.label.exists(element, label) - returns true or false related to label existance|function|core
|===

== apoc.load

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::import/load-csv.adoc[apoc.load.csv icon:book[]]

apoc.load.csv('url',{config}) YIELD lineNo, list, map - load CSV fom URL as stream of values,
 config contains any of: {skip:1,limit:5,header:false,sep:'TAB',ignore:['tmp'],nullValues:['na'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false}}|procedure|full
|**apoc.load.driver**

apoc.load.driver('org.apache.derby.jdbc.EmbeddedDriver') register JDBC driver of source database|procedure|full
|**apoc.load.html**

apoc.load.html('url',{name: jquery, name2: jquery}, config) YIELD value - Load Html page and return the result as a Map|procedure|full
|xref::database-integration/load-jdbc.adoc[apoc.load.jdbc icon:book[]]

apoc.load.jdbc('key or url','table or statement', params, config) YIELD row - load from relational database, from a full table or a sql statement|procedure|full
|xref::database-integration/load-jdbc.adoc[apoc.load.jdbcParams icon:book[]]

deprecated - please use: apoc.load.jdbc('key or url','',[params]) YIELD row - load from relational database, from a sql statement with parameters|procedure|full
|xref::database-integration/load-jdbc.adoc[apoc.load.jdbcUpdate icon:book[]]

apoc.load.jdbcUpdate('key or url','statement',[params],config) YIELD row - update relational database, from a SQL statement with optional parameters|procedure|full
|xref::import/load-json.adoc[apoc.load.json icon:book[]]

apoc.load.json('url',path, config) YIELD value -  import JSON as stream of values if the JSON was an array or a single value if it was a map|procedure|core
|xref::import/load-json.adoc[apoc.load.jsonArray icon:book[]]

apoc.load.jsonArray('url') YIELD value - load array from JSON URL (e.g. web-api) to import JSON as stream of values|procedure|core
|xref::import/load-json.adoc[apoc.load.jsonParams icon:book[]]

apoc.load.jsonParams('url',{header:value},payload, config) YIELD value - load from JSON URL (e.g. web-api) while sending headers / payload to import JSON as stream of values if the JSON was an array or a single value if it was a map|procedure|core
|**apoc.load.ldap**

apoc.load.ldap("key" or {connectionMap},{searchMap}) Load entries from an ldap source (yield entry)|procedure|full
|**apoc.load.xls**

apoc.load.xls('url','selector',{config}) YIELD lineNo, list, map - load XLS fom URL as stream of row values,
 config contains any of: {skip:1,limit:5,header:false,ignore:['tmp'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false, dateFormat:'iso_date', dateParse:['dd-MM-yyyy']}}|procedure|full
|xref::import/xml.adoc[apoc.load.xml icon:book[]]

apoc.load.xml('http://example.com/test.xml', 'xPath',config, false) YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.|procedure|core
|xref::import/xml.adoc[apoc.load.xmlSimple icon:book[]]

apoc.load.xmlSimple('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _children fields. This method does intentionally not work with XML mixed content.|procedure|core
|===

== apoc.lock

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-updates/locking.adoc[apoc.lock.all icon:book[]]

apoc.lock.all([nodes],[relationships]) acquires a write lock on the given nodes and relationships|procedure|core
|xref::graph-updates/locking.adoc[apoc.lock.nodes icon:book[]]

apoc.lock.nodes([nodes]) acquires a write lock on the given nodes|procedure|core
|xref::graph-updates/locking.adoc[apoc.lock.rels icon:book[]]

apoc.lock.rels([relationships]) acquires a write lock on the given relationship|procedure|core
|===

== apoc.log

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.log.debug**

apoc.log.debug(message, params) - logs debug message|procedure|full
|**apoc.log.error**

apoc.log.error(message, params) - logs error message|procedure|full
|**apoc.log.info**

apoc.log.info(message, params) - logs info message|procedure|full
|**apoc.log.stream**

apoc.log.stream('neo4j.log', { last: n }) - retrieve log file contents, optionally return only the last n lines|procedure|core
|**apoc.log.warn**

apoc.log.warn(message, params) - logs warn message|procedure|full
|===

== apoc.map

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::data-structures/map-functions.adoc[apoc.map.clean icon:book[]]

apoc.map.clean(map,[skip,keys],[skip,values]) yield map filters the keys and values contained in those lists, good for data cleaning from CSV/JSON|function|core
|xref::data-structures/map-functions.adoc[apoc.map.flatten icon:book[]]

apoc.map.flatten(map, delimiter:'.') yield map - flattens nested items in map using dot notation|function|core
|xref::data-structures/map-functions.adoc[apoc.map.fromLists icon:book[]]

apoc.map.fromLists([keys],[values])|function|core
|xref::data-structures/map-functions.adoc[apoc.map.fromNodes icon:book[]]

apoc.map.fromNodes(label, property)|function|core
|xref::data-structures/map-functions.adoc[apoc.map.fromPairs icon:book[]]

apoc.map.fromPairs([[key,value],[key2,value2],...])|function|core
|xref::data-structures/map-functions.adoc[apoc.map.fromValues icon:book[]]

apoc.map.fromValues([key1,value1,key2,value2,...])|function|core
|xref::data-structures/map-functions.adoc[apoc.map.get icon:book[]]

apoc.map.get(map,key,[default],[fail=true]) - returns value for key or throws exception if key doesn't exist and no default given|function|core
|xref::data-structures/map-functions.adoc[apoc.map.groupBy icon:book[]]

apoc.map.groupBy([maps/nodes/relationships],'key') yield value - creates a map of the list keyed by the given property, with single values|function|core
|xref::data-structures/map-functions.adoc[apoc.map.groupByMulti icon:book[]]

apoc.map.groupByMulti([maps/nodes/relationships],'key') yield value - creates a map of the list keyed by the given property, with list values|function|core
|xref::data-structures/map-functions.adoc[apoc.map.merge icon:book[]]

apoc.map.merge(first,second) - merges two maps|function|core
|xref::data-structures/map-functions.adoc[apoc.map.mergeList icon:book[]]

apoc.map.mergeList([{maps}]) yield value - merges all maps in the list into one|function|core
|xref::data-structures/map-functions.adoc[apoc.map.mget icon:book[]]

apoc.map.mget(map,key,[defaults],[fail=true])  - returns list of values for keys or throws exception if one of the key doesn't exist and no default value given at that position|function|core
|xref::data-structures/map-functions.adoc[apoc.map.removeKey icon:book[]]

apoc.map.removeKey(map,key,{recursive:true/false}) - remove the key from the map (recursively if recursive is true)|function|core
|xref::data-structures/map-functions.adoc[apoc.map.removeKeys icon:book[]]

apoc.map.removeKeys(map,[keys],{recursive:true/false}) - remove the keys from the map (recursively if recursive is true)|function|core
|xref::data-structures/map-functions.adoc[apoc.map.setEntry icon:book[]]

apoc.map.setEntry(map,key,value)|function|core
|xref::data-structures/map-functions.adoc[apoc.map.setKey icon:book[]]

apoc.map.setKey(map,key,value)|function|core
|xref::data-structures/map-functions.adoc[apoc.map.setLists icon:book[]]

apoc.map.setLists(map,[keys],[values])|function|core
|xref::data-structures/map-functions.adoc[apoc.map.setPairs icon:book[]]

apoc.map.setPairs(map,[[key1,value1],[key2,value2])|function|core
|xref::data-structures/map-functions.adoc[apoc.map.setValues icon:book[]]

apoc.map.setValues(map,[key1,value1,key2,value2])|function|core
|xref::data-structures/map-functions.adoc[apoc.map.sortedProperties icon:book[]]

apoc.map.sortedProperties(map, ignoreCase:true) - returns a list of key/value list pairs, with pairs sorted by keys alphabetically, with optional case sensitivity|function|core
|xref::data-structures/map-functions.adoc[apoc.map.submap icon:book[]]

apoc.map.submap(map,keys,[defaults],[fail=true])  - returns submap for keys or throws exception if one of the key doesn't exist and no default value given at that position|function|core
|xref::data-structures/map-functions.adoc[apoc.map.updateTree icon:book[]]

apoc.map.updateTree(tree,key,[[value,{data}]]) returns map - adds the {data} map on each level of the nested tree, where the key-value pairs match|function|core
|xref::data-structures/map-functions.adoc[apoc.map.values icon:book[]]

apoc.map.values(map, [key1,key2,key3,...],[addNullsForMissing]) returns list of values indicated by the keys|function|core
|===

== apoc.math

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::mathematical/math-functions.adoc[apoc.math.regr icon:book[]]

apoc.math.regr(label, propertyY, propertyX) - It calculates the coefficient of determination (R-squared) for the values of propertyY and propertyX in the provided label|procedure|core
|xref::mathematical/math-functions.adoc[apoc.math.maxByte icon:book[]]

apoc.math.maxByte() \| return the maximum value an byte can have|function|core
|xref::mathematical/math-functions.adoc[apoc.math.maxDouble icon:book[]]

apoc.math.maxDouble() \| return the largest positive finite value of type double|function|core
|xref::mathematical/math-functions.adoc[apoc.math.maxInt icon:book[]]

apoc.math.maxInt() \| return the maximum value an int can have|function|core
|xref::mathematical/math-functions.adoc[apoc.math.maxLong icon:book[]]

apoc.math.maxLong() \| return the maximum value a long can have|function|core
|xref::mathematical/math-functions.adoc[apoc.math.minByte icon:book[]]

apoc.math.minByte() \| return the minimum value an byte can have|function|core
|xref::mathematical/math-functions.adoc[apoc.math.minDouble icon:book[]]

apoc.math.minDouble() \| return the smallest positive nonzero value of type double|function|core
|xref::mathematical/math-functions.adoc[apoc.math.minInt icon:book[]]

apoc.math.minInt() \| return the minimum value an int can have|function|core
|xref::mathematical/math-functions.adoc[apoc.math.minLong icon:book[]]

apoc.math.minLong() \| return the minimum value a long can have|function|core
|xref::mathematical/math-functions.adoc[apoc.math.round icon:book[]]

apoc.math.round(value,[prec],mode=[CEILING,FLOOR,UP,DOWN,HALF_EVEN,HALF_DOWN,HALF_UP,DOWN,UNNECESSARY])|function|core
|===

[discrete]
== apoc.merge

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-updates/data-creation.adoc[apoc.merge.node icon:book[]]

"apoc.merge.node.eager(['Label'], identProps:{key:value, ...}, onCreateProps:{key:value,...}, onMatchProps:{key:value,...}}) - merge nodes with dynamic labels, with support for setting properties ON CREATE or ON MATCH|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.merge.relationship icon:book[]]

apoc.merge.relationship(startNode, relType,  identProps:{key:value, ...}, onCreateProps:{key:value, ...}, endNode, onMatchProps:{key:value, ...}) - merge relationship with dynamic type, with support for setting properties ON CREATE or ON MATCH|procedure|core
|===

== apoc.meta

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::database-introspection/meta.adoc[apoc.meta.data icon:book[]]

apoc.meta.data({config})  - examines a subset of the graph to provide a tabular meta information|procedure|core
|xref::database-introspection/meta.adoc[apoc.meta.graph icon:book[]]

apoc.meta.graph - examines the full graph to create the meta-graph|procedure|core
|xref::database-introspection/meta.adoc[apoc.meta.graphSample icon:book[]]

apoc.meta.graphSample() - examines the database statistics to build the meta graph, very fast, might report extra relationships|procedure|core
|xref::database-introspection/meta.adoc[apoc.meta.nodeTypeProperties icon:book[]]

apoc.meta.nodeTypeProperties()|procedure|core
|xref::database-introspection/meta.adoc[apoc.meta.relTypeProperties icon:book[]]

apoc.meta.relTypeProperties()|procedure|core
|xref::database-introspection/meta.adoc[apoc.meta.schema icon:book[]]

apoc.meta.schema({config})  - examines a subset of the graph to provide a map-like meta information|procedure|core
|xref::database-introspection/meta.adoc[apoc.meta.stats icon:book[]]

apoc.meta.stats  yield labelCount, relTypeCount, propertyKeyCount, nodeCount, relCount, labels, relTypes, stats \| returns the information stored in the transactional database statistics|procedure|core
|xref::database-introspection/meta.adoc[apoc.meta.subGraph icon:book[]]

apoc.meta.subGraph({labels:[labels],rels:[rel-types], excludes:[labels,rel-types]}) - examines a sample sub graph to create the meta-graph|procedure|core
|xref::database-introspection/meta.adoc[apoc.meta.isType icon:book[]]

apoc.meta.isType(value,type) - returns a row if type name matches none if not (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)|function|core
|xref::database-introspection/meta.adoc[apoc.meta.type icon:book[]]

apoc.meta.type(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)|function|core
|xref::database-introspection/meta.adoc[apoc.meta.typeName icon:book[]]

apoc.meta.typeName(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)|function|core
|xref::database-introspection/meta.adoc[apoc.meta.types icon:book[]]

apoc.meta.types(node-relationship-map)  - returns a map of keys to types|function|core
|===

== apoc.metrics

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.metrics.get**

apoc.metrics.get(metricName, {}) - retrieve a system metric by its metric name. Additional configuration options may be passed matching the options available for apoc.load.csv.|procedure|full
|**apoc.metrics.list**

apoc.metrics.list() - get a list of available metrics|procedure|full
|**apoc.metrics.storage**

apoc.metrics.storage(directorySetting) - retrieve storage metrics about the devices Neo4j uses for data storage. directorySetting may be any valid neo4j directory setting name, such as 'dbms.directories.data'.  If null is provided as a directorySetting, you will get back all available directory settings.  For a list of available directory settings, see the Neo4j operations manual reference on configuration settings.   Directory settings are **not** paths, they are a neo4j.conf setting key name|procedure|full
|===

[discrete]
== apoc.model

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::database-integration/database-modeling.adoc[apoc.model.jdbc icon:book[]]

apoc.model.jdbc('key or url', {schema:'<schema>', write: <true/false>, filters: { tables:[], views: [], columns: []}) YIELD nodes, relationships - load schema from relational database|procedure|full
|===

== apoc.mongodb

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::database-integration/mongodb.adoc[apoc.mongodb.count icon:book[]]

apoc.mongodb.count(host-or-key,db,collection,query) yield value - perform a find operation on mongodb collection|procedure|full
|xref::database-integration/mongodb.adoc[apoc.mongodb.delete icon:book[]]

apoc.mongodb.delete(host-or-key,db,collection,query) - delete the given documents from the mongodb collection and returns the number of affected documents|procedure|full
|xref::database-integration/mongodb.adoc[apoc.mongodb.find icon:book[]]

apoc.mongodb.find(host-or-key,db,collection,query,projection,sort,[compatibleValues=false\|true],skip-or-null,limit-or-null,[extractReferences=false\|true],[objectIdAsMap=true\|false]) yield value - perform a find,project,sort operation on mongodb collection|procedure|full
|xref::database-integration/mongodb.adoc[apoc.mongodb.first icon:book[]]

apoc.mongodb.first(host-or-key,db,collection,query,[compatibleValues=false\|true],[extractReferences=false\|true],[objectIdAsMap=true\|false]) yield value - perform a first operation on mongodb collection|procedure|full
|xref::database-integration/mongodb.adoc[apoc.mongodb.get icon:book[]]

apoc.mongodb.get(host-or-key,db,collection,query,[compatibleValues=false\|true],skip-or-null,limit-or-null,[extractReferences=false\|true],[objectIdAsMap=true\|false]) yield value - perform a find operation on mongodb collection|procedure|full
|xref::database-integration/mongodb.adoc[apoc.mongodb.insert icon:book[]]

apoc.mongodb.insert(host-or-key,db,collection,documents) - inserts the given documents into the mongodb collection|procedure|full
|xref::database-integration/mongodb.adoc[apoc.mongodb.update icon:book[]]

apoc.mongodb.update(host-or-key,db,collection,query,update) - updates the given documents from the mongodb collection and returns the number of affected documents|procedure|full
|===

== apoc.monitor

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::database-introspection/monitoring.adoc[apoc.monitor.ids icon:book[]]

apoc.monitor.ids() returns the object ids in use for this neo4j instance|procedure|core
|xref::database-introspection/monitoring.adoc[apoc.monitor.kernel icon:book[]]

apoc.monitor.kernel() returns informations about the neo4j kernel|procedure|core
|xref::database-introspection/monitoring.adoc[apoc.monitor.store icon:book[]]

apoc.monitor.store() returns informations about the sizes of the different parts of the neo4j graph store|procedure|core
|xref::database-introspection/monitoring.adoc[apoc.monitor.tx icon:book[]]

apoc.monitor.tx() returns informations about the neo4j transaction manager|procedure|core
|===

== apoc.neighbors

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-querying/neighborhood-search.adoc[apoc.neighbors.athop icon:book[]]

apoc.neighbors.athop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at a distance, can use '>' or '<' for all outgoing or incoming relationships|procedure|core
|xref::graph-querying/neighborhood-search.adoc[apoc.neighbors.byhop icon:book[]]

apoc.neighbors.byhop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at each distance, can use '>' or '<' for all outgoing or incoming relationships|procedure|core
|xref::graph-querying/neighborhood-search.adoc[apoc.neighbors.tohop icon:book[]]

apoc.neighbors.tohop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern up to a certain distance, can use '>' or '<' for all outgoing or incoming relationships|procedure|core
|===

== apoc.node

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-querying/node-querying.adoc[apoc.node.degree icon:book[]]

apoc.node.degree(node, rel-direction-pattern) - returns total degrees of the given relationships in the pattern, can use '>' or '<' for all outgoing or incoming relationships|function|core
|xref::graph-querying/node-querying.adoc[apoc.node.id icon:book[]]

returns id for (virtual) nodes|function|core
|xref::graph-querying/node-querying.adoc[apoc.node.labels icon:book[]]

returns labels for (virtual) nodes|function|core
|===

== apoc.nodes

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-querying/node-querying.adoc[apoc.nodes.collapse icon:book[]]

apoc.nodes.collapse([nodes...],[{properties:'overwrite' or 'discard' or 'combine'}]) yield from, rel, to merge nodes onto first in list|procedure|core
|xref::graph-querying/node-querying.adoc[apoc.nodes.delete icon:book[]]

apoc.nodes.delete(node\|nodes\|id\|[ids]) - quickly delete all nodes with these ids|procedure|core
|xref::graph-querying/node-querying.adoc[apoc.nodes.get icon:book[]]

apoc.nodes.get(node\|nodes\|id\|[ids]) - quickly returns all nodes with these ids|procedure|core
|xref::graph-querying/node-querying.adoc[apoc.nodes.group icon:book[]]

|procedure|core
|xref::graph-updates/data-creation.adoc[apoc.nodes.link icon:book[]]

apoc.nodes.link([nodes],'REL_TYPE') - creates a linked list of nodes from first to last|procedure|core
|xref::graph-querying/node-querying.adoc[apoc.nodes.rels icon:book[]]

apoc.get.rels(rel\|id\|[ids]) - quickly returns all relationships with these ids|procedure|core
|xref::graph-querying/node-querying.adoc[apoc.nodes.connected icon:book[]]

apoc.nodes.connected(start, end, rel-direction-pattern) - returns true when the node is connected to the other node, optimized for dense nodes|function|core
|xref::graph-querying/node-querying.adoc[apoc.nodes.isDense icon:book[]]

apoc.nodes.isDense(node) - returns true if it is a dense node|function|core
|===

== apoc.number

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::mathematical/math-functions.adoc[apoc.number.arabicToRoman icon:book[]]

apoc.number.arabicToRoman(number)  \| convert arabic numbers to roman|function|core
|xref::mathematical/number-conversions.adoc[apoc.number.format icon:book[]]

apoc.number.format(number)  \| format a long or double using the default system pattern and language to produce a string|function|core
|xref::mathematical/number-conversions.adoc[apoc.number.parseFloat icon:book[]]

apoc.number.parseFloat(text)  \| parse a text using the default system pattern and language to produce a double|function|core
|xref::mathematical/number-conversions.adoc[apoc.number.parseInt icon:book[]]

apoc.number.parseInt(text)  \| parse a text using the default system pattern and language to produce a long|function|core
|xref::mathematical/math-functions.adoc[apoc.number.romanToArabic icon:book[]]

apoc.number.romanToArabic(romanNumber)  \| convert roman numbers to arabic|function|core
|===

== apoc.path

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-querying/expand-paths.adoc[apoc.path.expand icon:book[]]

apoc.path.expand(startNode <id>\|Node\|list, 'TYPE\|TYPE_OUT>\|<TYPE_IN', '+YesLabel\|-NoLabel', minLevel, maxLevel ) yield path - expand from start node following the given relationships from min to max-level adhering to the label filters|procedure|core
|xref::graph-querying/expand-paths-config.adoc[apoc.path.expandConfig icon:book[]]

apoc.path.expandConfig(startNode <id>\|Node\|list, {minLevel,maxLevel,uniqueness,relationshipFilter,labelFilter,uniqueness:'RELATIONSHIP_PATH',bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield path - expand from start node following the given relationships from min to max-level adhering to the label filters. |procedure|core
|xref::graph-querying/path-querying.adoc[apoc.path.spanningTree icon:book[]]

apoc.path.spanningTree(startNode <id>\|Node\|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield path - expand a spanning tree reachable from start node following relationships to max-level adhering to the label filters|procedure|core
|xref::graph-querying/expand-subgraph.adoc[apoc.path.subgraphAll icon:book[]]

apoc.path.subgraphAll(startNode <id>\|Node\|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield nodes, relationships - expand the subgraph reachable from start node following relationships to max-level adhering to the label filters, and also return all relationships within the subgraph|procedure|core
|xref::graph-querying/path-querying.adoc[apoc.path.subgraphNodes icon:book[]]

apoc.path.subgraphNodes(startNode <id>\|Node\|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield node - expand the subgraph nodes reachable from start node following relationships to max-level adhering to the label filters|procedure|core
|xref::graph-querying/path-querying.adoc[apoc.path.combine icon:book[]]

apoc.path.combine(path1, path2) - combines the paths into one if the connecting node matches|function|core
|xref::graph-querying/path-querying.adoc[apoc.path.create icon:book[]]

apoc.path.create(startNode,[rels]) - creates a path instance of the given elements|function|core
|xref::graph-querying/path-querying.adoc[apoc.path.elements icon:book[]]

apoc.path.elements(path) - returns a list of node-relationship-node-...|function|core
|xref::graph-querying/path-querying.adoc[apoc.path.slice icon:book[]]

apoc.path.slice(path, [offset], [length]) - creates a sub-path with the given offset and length|function|core
|===

== apoc.periodic

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.periodic.cancel**

apoc.periodic.cancel(name) - cancel job with the given name|procedure|core
|xref::graph-updates/periodic-execution.adoc#periodic-commit[apoc.periodic.commit icon:book[]]

apoc.periodic.commit(statement,params) - runs the given statement in separate transactions until it returns 0|procedure|core
|xref::job-management/periodic-background.adoc[apoc.periodic.countdown icon:book[]]

apoc.periodic.countdown('name',statement,repeat-rate-in-seconds) submit a repeatedly-called background statement until it returns 0|procedure|core
|xref::graph-updates/periodic-execution.adoc#commit-batching[apoc.periodic.iterate icon:book[]]

apoc.periodic.iterate('statement returning items', 'statement per item', {batchSize:1000,iterateList:true,parallel:false,params:{},concurrency:50,retries:0}) YIELD batches, total - run the second statement for each item returned by the first statement. Returns number of batches and total processed rows|procedure|core
|xref::job-management/periodic-background.adoc[apoc.periodic.list icon:book[]]

apoc.periodic.list - list all jobs|procedure|core
|**apoc.periodic.repeat**

apoc.periodic.repeat('name',statement,repeat-rate-in-seconds, config) submit a repeatedly-called background statement. Fourth parameter 'config' is optional and can contain 'params' entry for nested statement.|procedure|core
|xref::graph-updates/periodic-execution.adoc#periodic-rock-n-roll[apoc.periodic.rock_n_roll icon:book[]]

apoc.periodic.rock_n_roll('some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows|procedure|full
|**apoc.periodic.rock_n_roll_while**

apoc.periodic.rock_n_roll_while('some cypher for knowing when to stop', 'some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows|procedure|full
|xref::job-management/periodic-background.adoc[apoc.periodic.submit icon:book[]]

apoc.periodic.submit('name',statement) - submit a one-off background statement|procedure|core
|===

== apoc.refactor

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.refactor.categorize**

apoc.refactor.categorize(sourceKey, type, outgoing, label, targetKey, copiedKeys, batchSize) turn each unique propertyKey into a category node and connect to it|procedure|core
|xref::graph-updates/graph-refactoring/clone-nodes.adoc[apoc.refactor.cloneNodes icon:book[]]

apoc.refactor.cloneNodes([node1,node2,...]) clone nodes with their labels and properties|procedure|core
|xref::graph-updates/graph-refactoring/clone-nodes.adoc[apoc.refactor.cloneNodesWithRelationships icon:book[]]

apoc.refactor.cloneNodesWithRelationships([node1,node2,...]) clone nodes with their labels, properties and relationships|procedure|core
|xref::graph-updates/graph-refactoring/clone-nodes.adoc[apoc.refactor.cloneSubgraph icon:book[]]

apoc.refactor.cloneSubgraph([node1,node2,...], [rel1,rel2,...]:[], {standinNodes:[], skipProperties:[]}) YIELD input, output, error \| clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the given relationships (will exist between cloned nodes only). If no relationships are provided, all relationships between the given nodes will be cloned. Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin.|procedure|core
|xref::graph-updates/graph-refactoring/clone-nodes.adoc[apoc.refactor.cloneSubgraphFromPaths icon:book[]]

apoc.refactor.cloneSubgraphFromPaths([path1, path2, ...], {standinNodes:[], skipProperties:[]}) YIELD input, output, error \| from the subgraph formed from the given paths, clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the relationships (will exist between cloned nodes only). Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin.|procedure|core
|**apoc.refactor.collapseNode**

apoc.refactor.collapseNode([node1,node2],'TYPE') collapse node to relationship, node with one rel becomes self-relationship|procedure|core
|**apoc.refactor.extractNode**

apoc.refactor.extractNode([rel1,rel2,...], [labels],'OUT','IN') extract node from relationships|procedure|core
|xref::graph-updates/graph-refactoring/redirect-relationship.adoc[apoc.refactor.from icon:book[]]

apoc.refactor.from(rel, startNode) redirect relationship to use new start-node|procedure|core
|xref::graph-updates/graph-refactoring/invert-relationship.adoc[apoc.refactor.invert icon:book[]]

apoc.refactor.invert(rel) inverts relationship direction|procedure|core
|xref::graph-updates/graph-refactoring/merge-nodes.adoc[apoc.refactor.mergeNodes icon:book[]]

apoc.refactor.mergeNodes([node1,node2],[{properties:'overwrite' or 'discard' or 'combine'}]) merge nodes onto first in list|procedure|core
|xref::graph-updates/graph-refactoring/merge-nodes.adoc[apoc.refactor.mergeRelationships icon:book[]]

apoc.refactor.mergeRelationships([rel1,rel2]) merge relationships onto first in list|procedure|core
|**apoc.refactor.normalizeAsBoolean**

apoc.refactor.normalizeAsBoolean(entity, propertyKey, true_values, false_values) normalize/convert a property to be boolean|procedure|core
|xref::graph-updates/graph-refactoring/set-relationship-type.adoc[apoc.refactor.setType icon:book[]]

apoc.refactor.setType(rel, 'NEW-TYPE') change relationship-type|procedure|core
|xref::graph-updates/graph-refactoring/redirect-relationship.adoc[apoc.refactor.to icon:book[]]

apoc.refactor.to(rel, endNode) redirect relationship to use new end-node|procedure|core
|===

[discrete]
== apoc.rel

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.rel.id**

returns id for (virtual) relationships|function|core
|**apoc.rel.type**

returns type for (virtual) relationships|function|core
|===

== apoc.schema

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::indexes/schema-index-operations.adoc[apoc.schema.assert icon:book[]]

apoc.schema.assert({indexLabel:[[indexKeys]], ...}, {constraintLabel:[constraintKeys], ...}, dropExisting : true) yield label, key, keys, unique, action - drops all other existing indexes and constraints when `dropExisting` is `true` (default is `true`), and asserts that at the end of the operation the given indexes and unique constraints are there, each label:key pair is considered one constraint/label. Non-constraint indexes can define compound indexes with label:[key1,key2...] pairings.|procedure|core
|xref::indexes/schema-index-operations.adoc[apoc.schema.nodes icon:book[]]

CALL apoc.schema.nodes([config]) yield name, label, properties, status, type|procedure|core
|xref::indexes/schema-index-operations.adoc[apoc.schema.relationships icon:book[]]

CALL apoc.schema.relationships([config]) yield name, startLabel, type, endLabel, properties, status|procedure|core
|===

[discrete]
== apoc.scoring

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.scoring.existence**

apoc.scoring.existence(5, true) returns the provided score if true, 0 if false|function|core
|**apoc.scoring.pareto**

apoc.scoring.pareto(10, 20, 100, 11) applies a Pareto scoring function over the inputs|function|core
|===

== apoc.search

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.search.multiSearchReduced**

Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.multiSearchReduced( map of label and properties which will be searched upon, operator: EXACT \| CONTAINS \| STARTS WITH \| ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.|procedure|core
|xref::graph-querying/parallel-node-search.adoc[apoc.search.node icon:book[]]

Do a parallel search over multiple indexes returning nodes. usage apoc.search.node( map of label and properties which will be searched upon, operator: EXACT \| CONTAINS \| STARTS WITH \| ENDS WITH, searchValue ) returns all the DISTINCT Nodes found in the different searches.|procedure|core
|xref::graph-querying/parallel-node-search.adoc[apoc.search.nodeAll icon:book[]]

Do a parallel search over multiple indexes returning nodes. usage apoc.search.nodeAll( map of label and properties which will be searched upon, operator: EXACT \| CONTAINS \| STARTS WITH \| ENDS WITH, searchValue ) returns all the Nodes found in the different searches.|procedure|core
|xref::graph-querying/parallel-node-search.adoc[apoc.search.nodeAllReduced icon:book[]]

Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched property. apoc.search.nodeShortAll( map of label and properties which will be searched upon, operator: EXACT / CONTAINS / STARTS WITH \| ENDS WITH / = / <> / < / > ..., value ). All 'hits' are returned.|procedure|core
|xref::graph-querying/parallel-node-search.adoc[apoc.search.nodeReduced icon:book[]]

Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.nodeReduced( map of label and properties which will be searched upon, operator: EXACT \| CONTAINS \| STARTS WITH \| ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.|procedure|core
|===

== apoc.spatial

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::misc/spatial.adoc[apoc.spatial.geocode icon:book[]]

apoc.spatial.geocode('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from a geocoding service (the default one is OpenStreetMap)|procedure|core
|xref::misc/spatial.adoc[apoc.spatial.geocodeOnce icon:book[]]

apoc.spatial.geocodeOnce('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from a geocoding service (the default one is OpenStreetMap)|procedure|core
|xref::misc/spatial.adoc[apoc.spatial.reverseGeocode icon:book[]]

apoc.spatial.reverseGeocode(latitude,longitude) YIELD location, latitude, longitude, description - look up address from latitude and longitude from a geocoding service (the default one is OpenStreetMap)|procedure|core
|xref::misc/spatial.adoc[apoc.spatial.sortByDistance icon:book[]]

apoc.spatial.sortPathsByDistance(List<Path>) sort the given paths based on the geo informations (lat/long) in ascending order|procedure|core
|===

== apoc.static

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::misc/static-values.adoc[apoc.static.get icon:book[]]

apoc.static.get(name) - returns statically stored value from config (apoc.static.<key>) or server lifetime storage|procedure|full
|xref::misc/static-values.adoc[apoc.static.list icon:book[]]

apoc.static.list(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage|procedure|full
|xref::misc/static-values.adoc[apoc.static.set icon:book[]]

apoc.static.set(name, value) - stores value under key for server lifetime storage, returns previously stored or configured value|procedure|full
|xref::misc/static-values.adoc[apoc.static.get icon:book[]]

apoc.static.get(name) - returns statically stored value from config (apoc.static.<key>) or server lifetime storage|function|full
|xref::misc/static-values.adoc[apoc.static.getAll icon:book[]]

apoc.static.getAll(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage|function|full
|===

[discrete]
== apoc.stats

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.stats.degrees**

|procedure|core
|===

[discrete]
== apoc.systemdb

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::database-introspection/systemdb.adoc[apoc.systemdb.execute icon:book[]]

|procedure|full
|xref::database-introspection/systemdb.adoc[apoc.systemdb.graph icon:book[]]

|procedure|full
|===

== apoc.temporal

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::temporal/temporal-conversions.adoc[apoc.temporal.format icon:book[]]

apoc.temporal.format(input, format) \| Format a temporal value|function|core
|xref::temporal/temporal-conversions.adoc[apoc.temporal.formatDuration icon:book[]]

apoc.temporal.formatDuration(input, format) \| Format a Duration|function|core
|xref::temporal/temporal-conversions.adoc[apoc.temporal.toZonedTemporal icon:book[]]

apoc.temporal.toZonedTemporal('2012-12-23 23:59:59','yyyy-MM-dd HH:mm:ss', 'UTC-hour-offset') parse date string using the specified format to specified timezone|function|core
|===

== apoc.text

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::misc/text-functions.adoc[apoc.text.doubleMetaphone icon:book[]]

apoc.text.doubleMetaphone(value) yield value - Compute the Double Metaphone phonetic encoding of all words of the text value which can be a single string or a list of strings|procedure|core
|xref::misc/text-functions.adoc[apoc.text.phonetic icon:book[]]

apoc.text.phonetic(value) yield value - Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings|procedure|core
|xref::misc/text-functions.adoc[apoc.text.phoneticDelta icon:book[]]

apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta - Compute the US_ENGLISH soundex character difference between two given strings|procedure|core
|xref::misc/text-functions.adoc[apoc.text.base64Decode icon:book[]]

apoc.text.base64Decode(text) YIELD value - Decode Base64 encoded string|function|core
|xref::misc/text-functions.adoc[apoc.text.base64Encode icon:book[]]

apoc.text.base64Encode(text) YIELD value - Encode a string with Base64|function|core
|xref::misc/text-functions.adoc[apoc.text.base64UrlDecode icon:book[]]

apoc.text.base64UrlDecode(url) YIELD value - Decode Base64 encoded url|function|core
|xref::misc/text-functions.adoc[apoc.text.base64UrlEncode icon:book[]]

apoc.text.base64UrlEncode(text) YIELD value - Encode a url with Base64|function|core
|xref::misc/text-functions.adoc[apoc.text.byteCount icon:book[]]

apoc.text.byteCount(text,[charset]) - return size of text in bytes|function|core
|xref::misc/text-functions.adoc[apoc.text.bytes icon:book[]]

apoc.text.bytes(text,[charset]) - return bytes of the text|function|core
|xref::misc/text-functions.adoc[apoc.text.camelCase icon:book[]]

apoc.text.camelCase(text) YIELD value - Convert a string to camelCase|function|core
|xref::misc/text-functions.adoc[apoc.text.capitalize icon:book[]]

apoc.text.capitalize(text) YIELD value - capitalise the first letter of the word|function|core
|xref::misc/text-functions.adoc[apoc.text.capitalizeAll icon:book[]]

apoc.text.capitalizeAll(text) YIELD value - capitalise the first letter of every word in the text|function|core
|xref::misc/text-functions.adoc[apoc.text.charAt icon:book[]]

apoc.text.charAt(text, index) - the decimal value of the character at the given index|function|core
|xref::misc/text-functions.adoc[apoc.text.clean icon:book[]]

apoc.text.clean(text) - strip the given string of everything except alpha numeric characters and convert it to lower case.|function|core
|xref::misc/text-functions.adoc[apoc.text.code icon:book[]]

apoc.text.code(codepoint) - Returns the unicode character of the given codepoint|function|core
|xref::misc/text-functions.adoc[apoc.text.compareCleaned icon:book[]]

apoc.text.compareCleaned(text1, text2) - compare the given strings stripped of everything except alpha numeric characters converted to lower case.|function|core
|xref::misc/text-functions.adoc[apoc.text.decapitalize icon:book[]]

apoc.text.decapitalize(text) YIELD value - decapitalize the first letter of the word|function|core
|xref::misc/text-functions.adoc[apoc.text.decapitalizeAll icon:book[]]

apoc.text.decapitalizeAll(text) YIELD value - decapitalize the first letter of all words|function|core
|xref::misc/text-functions.adoc[apoc.text.distance icon:book[]]

apoc.text.distance(text1, text2) - compare the given strings with the Levenshtein distance algorithm.|function|core
|xref::misc/text-functions.adoc[apoc.text.doubleMetaphone icon:book[]]

apoc.text.doubleMetaphone(value) yield value - Compute the Double Metaphone phonetic encoding of all words of the text value|function|core
|xref::misc/text-functions.adoc[apoc.text.format icon:book[]]

apoc.text.format(text,[params],language) - sprintf format the string with the params given|function|core
|xref::misc/text-functions.adoc[apoc.text.fuzzyMatch icon:book[]]

apoc.text.fuzzyMatch(text1, text2) - check if 2 words can be matched in a fuzzy way. Depending on the length of the String it will allow more characters that needs to be edited to match the second String.|function|core
|xref::misc/text-functions.adoc[apoc.text.hammingDistance icon:book[]]

apoc.text.hammingDistance(text1, text2) - compare the given strings with the Hamming distance algorithm.|function|core
|xref::misc/text-functions.adoc[apoc.text.hexCharAt icon:book[]]

apoc.text.hexCharAt(text, index) - the hex value string of the character at the given index|function|core
|xref::misc/text-functions.adoc[apoc.text.hexValue icon:book[]]

apoc.text.hexValue(value) - the hex value string of the given number|function|core
|xref::misc/text-functions.adoc[apoc.text.indexOf icon:book[]]

apoc.text.indexOf(text, lookup, from=0, to=-1==len) - find the first occurence of the lookup string in the text, from inclusive, to exclusive, -1 if not found, null if text is null.|function|core
|xref::misc/text-functions.adoc[apoc.text.indexesOf icon:book[]]

apoc.text.indexesOf(text, lookup, from=0, to=-1==len) - finds all occurences of the lookup string in the text, return list, from inclusive, to exclusive, empty list if not found, null if text is null.|function|core
|xref::misc/text-functions.adoc[apoc.text.jaroWinklerDistance icon:book[]]

apoc.text.jaroWinklerDistance(text1, text2) - compare the given strings with the Jaro-Winkler distance algorithm.|function|core
|xref::misc/text-functions.adoc[apoc.text.join icon:book[]]

apoc.text.join(['text1','text2',...], delimiter) - join the given strings with the given delimiter.|function|core
|xref::misc/text-functions.adoc[apoc.text.levenshteinDistance icon:book[]]

apoc.text.levenshteinDistance(text1, text2) - compare the given strings with the Levenshtein distance algorithm.|function|core
|xref::misc/text-functions.adoc[apoc.text.levenshteinSimilarity icon:book[]]

apoc.text.levenshteinSimilarity(text1, text2) - calculate the similarity (a value within 0 and 1) between two texts.|function|core
|xref::misc/text-functions.adoc[apoc.text.lpad icon:book[]]

apoc.text.lpad(text,count,delim) YIELD value - left pad the string to the given width|function|core
|xref::misc/text-functions.adoc[apoc.text.phonetic icon:book[]]

apoc.text.phonetic(text) yield value - Compute the US_ENGLISH phonetic soundex encoding of all words of the text|function|core
|xref::misc/text-functions.adoc[apoc.text.random icon:book[]]

apoc.text.random(length, valid) YIELD value - generate a random string|function|core
|xref::misc/text-functions.adoc[apoc.text.regexGroups icon:book[]]

apoc.text.regexGroups(text, regex) - return all matching groups of the regex on the given text.|function|core
|xref::misc/text-functions.adoc[apoc.text.regreplace icon:book[]]

apoc.text.regreplace(text, regex, replacement) - replace each substring of the given string that matches the given regular expression with the given replacement.|function|core
|xref::misc/text-functions.adoc[apoc.text.repeat icon:book[]]

apoc.text.repeat(item, count) - string multiplication|function|core
|xref::misc/text-functions.adoc[apoc.text.replace icon:book[]]

apoc.text.replace(text, regex, replacement) - replace each substring of the given string that matches the given regular expression with the given replacement.|function|core
|xref::misc/text-functions.adoc[apoc.text.rpad icon:book[]]

apoc.text.rpad(text,count,delim) YIELD value - right pad the string to the given width|function|core
|xref::misc/text-functions.adoc[apoc.text.slug icon:book[]]

apoc.text.slug(text, delim) - slug the text with the given delimiter|function|core
|xref::misc/text-functions.adoc[apoc.text.snakeCase icon:book[]]

apoc.text.snakeCase(text) YIELD value - Convert a string to snake-case|function|core
|xref::misc/text-functions.adoc[apoc.text.sorensenDiceSimilarity icon:book[]]

apoc.text.sorensenDiceSimilarityWithLanguage(text1, text2, languageTag) - compare the given strings with the Sørensen–Dice coefficient formula, with the provided IETF language tag|function|core
|xref::misc/text-functions.adoc[apoc.text.split icon:book[]]

apoc.text.split(text, regex, limit) - splits the given text around matches of the given regex.|function|core
|xref::misc/text-functions.adoc[apoc.text.swapCase icon:book[]]

apoc.text.swapCase(text) YIELD value - Swap the case of a string|function|core
|xref::misc/text-functions.adoc[apoc.text.toCypher icon:book[]]

apoc.text.toCypher(value, {skipKeys,keepKeys,skipValues,keepValues,skipNull,node,relationship,start,end}) \| tries it's best to convert the value to a cypher-property-string|function|core
|xref::misc/text-functions.adoc[apoc.text.toUpperCase icon:book[]]

apoc.text.toUpperCase(text) YIELD value - Convert a string to UPPER_CASE|function|core
|xref::misc/text-functions.adoc[apoc.text.upperCamelCase icon:book[]]

apoc.text.upperCamelCase(text) YIELD value - Convert a string to camelCase|function|core
|xref::misc/text-functions.adoc[apoc.text.urldecode icon:book[]]

apoc.text.urldecode(text) - return the urldecoded text|function|core
|xref::misc/text-functions.adoc[apoc.text.urlencode icon:book[]]

apoc.text.urlencode(text) - return the urlencoded text|function|core
|===

== apoc.trigger

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::job-management/triggers.adoc[apoc.trigger.add icon:book[]]

add a trigger kernelTransaction under a name, in the kernelTransaction you can use {createdNodes}, {deletedNodes} etc., the selector is {phase:'before/after/rollback'} returns previous and new trigger information. Takes in an optional configuration.|procedure|core
|xref::job-management/triggers.adoc[apoc.trigger.list icon:book[]]

list all installed triggers|procedure|core
|xref::job-management/triggers.adoc[apoc.trigger.pause icon:book[]]

CALL apoc.trigger.pause(name) \| it pauses the trigger|procedure|core
|xref::job-management/triggers.adoc[apoc.trigger.remove icon:book[]]

remove previously added trigger, returns trigger information|procedure|core
|xref::job-management/triggers.adoc[apoc.trigger.removeAll icon:book[]]

removes all previously added trigger, returns trigger information|procedure|core
|xref::job-management/triggers.adoc[apoc.trigger.resume icon:book[]]

CALL apoc.trigger.resume(name) \| it resumes the paused trigger|procedure|core
|xref::job-management/triggers.adoc[apoc.trigger.nodesByLabel icon:book[]]

|function|full
|xref::job-management/triggers.adoc[apoc.trigger.propertiesByKey icon:book[]]

|function|full
|===

[discrete]
== apoc.ttl

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-updates/ttl.adoc[apoc.ttl.expire icon:book[]]

CALL apoc.ttl.expireAtInstant(node,time,'time-unit') - expire node at specified time by setting :TTL label and `ttl` property|procedure|full
|xref::graph-updates/ttl.adoc[apoc.ttl.expireIn icon:book[]]

CALL apoc.ttl.expireAfterTimeLength(node,timeDelta,'time-unit') - expire node after specified length of time time by setting :TTL label and `ttl` property|procedure|full
|===

== apoc.util

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.util.sleep**

apoc.util.sleep(<duration>) \| sleeps for <duration> millis, transaction termination is honored|procedure|core
|**apoc.util.validate**

apoc.util.validate(predicate, message, params) \| if the predicate yields to true raise an exception|procedure|core
|xref::misc/text-functions.adoc#text-functions-hashing[apoc.util.md5 icon:book[]]

apoc.util.md5([values]) \| computes the md5 of the concatenation of all string values of the list|function|core
|xref::misc/text-functions.adoc#text-functions-hashing[apoc.util.sha1 icon:book[]]

apoc.util.sha1([values]) \| computes the sha1 of the concatenation of all string values of the list|function|core
|**apoc.util.sha256**

apoc.util.sha256([values]) \| computes the sha256 of the concatenation of all string values of the list|function|core
|**apoc.util.sha384**

apoc.util.sha384([values]) \| computes the sha384 of the concatenation of all string values of the list|function|core
|**apoc.util.sha512**

apoc.util.sha512([values]) \| computes the sha512 of the concatenation of all string values of the list|function|core
|===

== apoc.uuid

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|xref::graph-updates/uuid.adoc[apoc.uuid.install icon:book[]]

CALL apoc.uuid.install(label, {addToExistingNodes: true/false, uuidProperty: 'uuid'}) yield label, installed, properties, batchComputationResult \| it will add the uuid transaction handler
for the provided `label` and `uuidProperty`, in case the UUID handler is already present it will be replaced by the new one|procedure|full
|xref::graph-updates/uuid.adoc[apoc.uuid.list icon:book[]]

CALL apoc.uuid.list() yield label, installed, properties \| provides a list of all the uuid handlers installed with the related configuration|procedure|full
|xref::graph-updates/uuid.adoc[apoc.uuid.remove icon:book[]]

CALL apoc.uuid.remove(label) yield label, installed, properties \| remove previously added uuid handler and returns uuid information. All the existing uuid properties are left as-is|procedure|full
|xref::graph-updates/uuid.adoc[apoc.uuid.removeAll icon:book[]]

CALL apoc.uuid.removeAll() yield label, installed, properties \| it removes all previously added uuid handlers and returns uuids information. All the existing uuid properties are left as-is|procedure|full
|===

[discrete]
== apoc.warmup

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.warmup.run**

apoc.warmup.run(loadProperties=false,loadDynamicProperties=false,loadIndexes=false) - quickly loads all nodes and rels into memory by skipping one page at a time|procedure|core
|===

[discrete]
== apoc.xml

[.procedures, opts=header, cols='5a,1,1']
|===
| Qualified Name | Type | Release
|**apoc.xml.import**

Deprecated by apoc.import.xml|procedure|core
|xref::import/xml.adoc[apoc.xml.parse icon:book[]]

RETURN apoc.xml.parse(<xml string>, <xPath string>, config, false) AS value|function|core
|===

